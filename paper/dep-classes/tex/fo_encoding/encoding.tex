\documentclass[a4paper]{article}

%% packages
%%%%%%%%%%%
\usepackage[utf8x]{inputenc}
\usepackage[USenglish]{babel}
\usepackage{amsbsy,amscd,amsfonts,amssymb,amstext,amsmath,amsthm,latexsym}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{dot2texi}
\usepackage{url}
\usepackage{hyperref}
\usepackage[nottoc]{tocbibind}
\usepackage{pdfpages}

\usepackage{syntax} % for bnf grammar
\usepackage{bussproofs} % for type rules
\usepackage{todonotes}

\usepackage{float} % for figures
\floatstyle{boxed}
\restylefloat{figure}

\usepackage{listings}
\usepackage{xcolor}
%\usepackage{tikz}
\usetikzlibrary{positioning,chains,shapes.arrows,shapes.geometric,fit,calc,arrows,decorations.pathmorphing}

%\usepackage{subfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{cleveref}

%% options
%%%%%%%%%%
% Currently no such things seem to be needed.
% \newtheorem{definition}{Definition}
% \newtheorem{example}{Example}
% \newtheorem{lemma}{Lemma}
% \newtheorem{theorem}{Theorem}
% \newtheorem{claim}{Claim}
% \numberwithin{definition}{chapter}

\input{macros}
%\input{tikz}

\begin{document}
% Table of contents
%%%%%%%%%%%%%%%%%%%
%\tableofcontents

% Content
%%%%%%%%%
\section{How do we check entailments?}
\begin{enumerate}
  \item Create set of ``axioms'' based on the program and the entailment to check
  \begin{enumerate}
    \item Datatype Declarations
    \begin{itemize}
      \item Enumeration types: Variables, Classes, Fields
      \item ADT: Path
    \end{itemize}
    \item Function Declarations
    \begin{itemize}
      \item Declared: path-equivalence, instance-of, instantiated-by
      \item Defined recursively: substitute
    \end{itemize}
    \item Calculus rules as all quantified formulas
    \begin{itemize}
      \item Static Rules: C-Refl, C-Class, C-Subst
      \item Template Rules: C-Prog
    \end{itemize}
    \item Assert entailment to be checked: $c_1,...,c_n \vdash c \Rightarrow \neg (c_1 \land ... \land c_n → c)$
  \end{enumerate}
  \item Obtain Solution: Does the entailment contradict the rules?
  \begin{itemize}
    \item If unsat: valid/correct entailment.
    \item If sat: invalid entailment.
  \end{itemize}
\end{enumerate}

\subsection{General First-Order Encoding Template}
\begin{align}
  %&\texttt{\Variable~(...)}~~~~~\texttt{\Field~(...)}~~~~~\texttt{\Class~(...)}\\
  &\texttt{\Variable~(...)}\\
  &\texttt{\Field~(...)}\\
  &\texttt{\Class~(...)}\\
  &\Path~((\Variable)~(\Path~\Field))\\
  &\pathEq{}{}\!\!: \Path \times \Path \rightarrow \TBool \\
  &\instOf{}{}\!\!: \Path \times \Class \rightarrow \TBool\\
  &\instBy{}{}\!\!: \Path \times \Class \rightarrow \TBool\\
  &{\_}_{\sub{}{}}\!\!: \Path \times \Variable \times \Path \rightarrow \Path\\
  % C-Refl
  &\forall \sortedVar{p}{\Path}.~\pathEq{p}{p}\\
  % C-Class
  &\forall \sortedVar{a}{\TBool}, \sortedVar{p}{\Path}, \sortedVar{c}{\Class}.\\
  &\quad(a \rightarrow \instBy{p}{c}) \rightarrow (a \rightarrow \instOf{p}{c})\\
  % C-Subst: pathEq
  &\forall \sortedVar{a}{\TBool}, \sortedVar{p}{\Path}, \sortedVar{q}{\Path}, \sortedVar{r}{\Path}, \sortedVar{s}{\Path}, \sortedVar{x}{\Variable}.\\
  &\quad (a \rightarrow \pathEq{p_{\sub{x}{r}}}{q_{\sub{x}{r}}} \land (a \rightarrow \pathEq{s}{r})) \rightarrow\\
  &\qquad (a \rightarrow \pathEq{p_{\sub{x}{s}}}{q_{\sub{x}{s}}})\\
  % C-Subst: instOf
  &\forall \sortedVar{a}{\TBool}, \sortedVar{p}{\Path}, \sortedVar{c}{\Class}, \sortedVar{r}{\Path}, \sortedVar{s}{\Path}, \sortedVar{x}{\Variable}.\\
  &\quad (a \rightarrow \instOf{p_{\sub{x}{r}}}{c} \land (a \rightarrow \pathEq{s}{r})) \rightarrow\\
  &\qquad (a \rightarrow \instOf{p_{\sub{x}{s}}}{c})\\
  % C-Subst: instBy
  &\forall \sortedVar{a}{\TBool}, \sortedVar{p}{\Path}, \sortedVar{c}{\Class}, \sortedVar{r}{\Path}, \sortedVar{s}{\Path}, \sortedVar{x}{\Variable}.\\
  &\quad (a \rightarrow \instBy{p_{\sub{x}{r}}}{c} \land (a \rightarrow \pathEq{s}{r})) \rightarrow\\
  &\qquad (a \rightarrow \instBy{p_{\sub{x}{s}}}{c})\\
  % C-Prog
  &\forall \sortedVar{a}{\TBool}, \sortedVar{p}{\Path}.~(a \rightarrow \bigwedge \hole) \rightarrow (a \rightarrow \instOf{p}{\hole})
\end{align}

\subsection{Natural Numbers Program}
\begin{align}
&\constr{\texttt{Zero}}{x}{\epsilon}\\
&\constr{\texttt{Succ}}{x}{\instOf{x.p}{\texttt{Nat}}}\\
&\progEnt{x}{\instOf{x}{\texttt{Zero}}}{\instOf{x}{\texttt{Nat}}}\\
&\progEnt{x}{\instOf{x}{\texttt{Succ}}, \instOf{x.p}{\texttt{Nat}}}{\instOf{x}{\texttt{Nat}}}\\
&\mDecl{\texttt{prev}}{x}{\instOf{x}{\texttt{Nat}}}{\type{y}{\instOf{y}{\texttt{Nat}}}}\\
&\mImpl{\texttt{prev}}{x}{\instOf{x}{\texttt{Zero}}}{\type{y}{\instOf{y}{\texttt{Nat}}}}{\newInstNoArgs{\texttt{Zero}}}\\
&\mImpl{\texttt{prev}}{x}{\instOf{x}{\texttt{Succ}}, \instOf{x.p}{\texttt{Nat}}}{\type{y}{\instOf{y}{\texttt{Nat}}}}{x.p}
\end{align}

\subsection{C-Prog Rules for Natural Numbers Program}
\begin{align}
  &\forall \sortedVar{a}{\TBool}, \sortedVar{p}{\Path}.\\
  &\quad (a \rightarrow \instOf{p}{\Zero}) \rightarrow\\
  &\qquad (a \rightarrow \instOf{p}{\Nat})\\
  &\forall \sortedVar{a}{\TBool}, \sortedVar{p}{\Path}.\\
  &\quad (a \rightarrow \instOf{p}{\Succ} \land \instOf{x.p_{\sub{x}{p}}}{\Nat}) \rightarrow\\
  &\qquad (a \rightarrow \instOf{p}{\Nat})
\end{align}

\section{Example Entailments}
\subsection{Working valid entailment}
$\entails{\instBy{p}{\Zero}}{\instOf{p}{\Nat}}$
\begin{itemize}
  \item Checks unsatisfiable
  \item Unsat Core: C-Class, C-Prog-Zero
\end{itemize}

\subsection{Working invalid entailment}
TODO: search typechecking tests for (non-trivial) SAT entailment\\
$\entails{·}{\pathEq{x}{y}}$
\begin{itemize}
  \item Checks satisfiable
  \item Model: $\pathEq{p}{q} \doteq p=q$
\end{itemize}

\subsection{Non-working invalid entailment}
$\entails{\pathEq{x}{y}}{\pathEq{x}{z}}$
\begin{itemize}
  \item Checks unsatisfiable, but shouldn't
  \item Unsat Core: C-Subst-PathEq
  \item TODO: possible reason? (check instantiation of subst rule)
\end{itemize}

\subsection{Non-working invalid entailment}
fieldAccessTimeout.smt
\begin{itemize}
  \item Neither checks satisfiable nor unsatisfiable.
  \item Solver has ``infinite'' runtime.
  \item TODO: check manually for a model?
\end{itemize}

\section{Undefinedness}
\subsection{adding $\neg \pathEq{x}{x.p}$ results in ???}
\subsection{asserting $\instOf{x}{\Zero} \land \instOf{x}{\Nat}$ is SAT}
But with further investigation, again doesn't seem to be a problem,
as we are searching conflicts

\end{document}
