\documentclass[a4paper]{article}

%% packages
%%%%%%%%%%%
\usepackage[utf8x]{inputenc}
\usepackage[USenglish]{babel}
\usepackage{amsbsy,amscd,amsfonts,amssymb,amstext,amsmath,amsthm,latexsym}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{dot2texi}
\usepackage{url}
\usepackage{hyperref}
\usepackage[nottoc]{tocbibind}
\usepackage{pdfpages}

\usepackage{syntax}     % for bnf grammar
\usepackage{bussproofs} % for type rules
\usepackage{todonotes}

\usepackage{float}      % for figures
\floatstyle{boxed}
\restylefloat{figure}

\usepackage{listings}
\usepackage{xcolor}
%\usepackage{tikz}
%\usetikzlibrary{positioning,chains,shapes.arrows,shapes.geometric,fit,calc,arrows,decorations.pathmorphing}

%\usepackage{subfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{cleveref}   % for better references with \Cref
\usepackage{parskip}    % line breaks in texts

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\input{macros}
%\input{tikz}

\begin{document}

% \section{Overview}
\section{DCC recap}
\subsection{Syntax}
\label{sec:syntax}
%\begin{figure}[h]
  \begin{align*}
    P &::= \ovl{D} && \text{(Program)}\\
    D &::= \constructorDeclaration{C}{x}{\ovl{a}}
      \mid \programEntailment{x}{\ovl{a}}{a}
      \mid \abstractMethodDeclaration{m}{x}{\ovl{a}}{t}
      \mid \methodImplementation{m}{x}{\ovl{a}}{t}{e} && \text{(Decl)}\\
    t &::= \type{x}{\ovl{a}} && \text{(Type)}\\
    a &::= \pathEq{p}{p}
      \mid \instOf{p}{C}
      \mid \instBy{p}{C} && \text{(Constr)}\\
    p &::= x \mid p.f && \text{(Path)}\\
    e &::= x
      \mid e.f
      \mid \objConstr{C}{\pathEq{\ovl{f}}{\ovl{e}}} && \text{(Expr)}
  \end{align*}
%\caption{DCC Syntax}
%\label{fig:syntax}
%\end{figure}

\subsection{Constraint Entailment}
\label{sec:constraint-entailment}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[C-Ident]{}{
      \entails{a}{a}
    }
    \and
    \inferrule[C-Refl]{}{
      \entails{\epsilon}{\pathEq{p}{p}}
    }
    \and
    \inferrule[C-Class]{
      \entails{\ovl{a}}{\instBy{p}{C}}
    }{
      \entails{\ovl{a}}{\instOf{p}{C}}
    }
    \and
    \inferrule[C-Cut]{
      \entails{\ovl{a}}{c}\\
      \entails{\ovl{a'},c}{b}
    }{
      \entails{\ovl{a},\ovl{a'}}{b}
    }
    \and
    \inferrule[C-Subst]{
      \entails{\ovl{a}}{a_{\sub{x}{p}}}\\
      \entails{\ovl{a}}{\pathEq{p'}{p}}
    }{
      \entails{\ovl{a}}{a_{\sub{x}{p'}}}
    }
    \and
    \inferrule[C-Prog]{
      (\programEntailment{x}{\ovl{a}}{a}) \in P\\
      \entails{\ovl{b}}{\ovl{a}_{\sub{x}{p}}}
    }{
      \entails{\ovl{a}}{a_{\sub{x}{p}}}
    }
  \end{mathpar}
%  \caption{Constraint Entailment}
%  \label{fig:constraint-entailment}
%\end{figure}

\subsection{Operational Semantics}
\label{sec:operational-semantics}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[R-New]{
      x \not \in \mathit{dom}(h)\\
      o = \stdobj\\\\
      \constructorDeclaration{C}{x}{\ovl{b}} \in P\\
      \entails{\mIt{HC}(h), \mIt{OC}(x, o)}{\ovl{b}}
    }{
      \pair{h}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}}} \rightarrow
        \pair{h, x \mapsto o}{x}
    }
    \and
    \inferrule[R-Field]{
      (\pathEq{x.f}{y}) \in \mIt{HC}(h)
    }{
      \pair{h}{x.f} \rightarrow
        \pair{h}{y}
    }
    \and
    \inferrule[R-Call]{
      S = \{ \pair{\ovl{a}}{e} | \pair{\ovl{a}}{e} \in \mIt{mImpl}(m, x) \land \entails{\mIt{HC}(h)}{\ovl{a}} \}\\
      \pair{\ovl{a}}{e} \in S\\
      \forall \pair{\ovl{a'}}{e'} \in S.~(e' \neq e) \longrightarrow \entails{\ovl{a'}}{\ovl{a}} \land \neg \entails{\ovl{a}}{\ovl{a'}}
    }{
      \pair{h}{m(x)} \rightarrow
        \pair{h}{e}
    }
    \and
    \inferrule[RC-Field]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{e.f} \rightarrow
        \pair{h'}{e'.f}
    }
    \and
    \inferrule[RC-Call]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{m(e)} \rightarrow
        \pair{h'}{m(e')}
    }
    \and
    \inferrule[RC-New]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}, \pathEq{f}{e}, \pathEq{\ovl{f'}}{\ovl{e'}}}} \rightarrow
        \pair{h'}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}, \pathEq{f}{e'}, \pathEq{\ovl{f'}}{\ovl{e'}}}}
    }
  \end{mathpar}
%  \caption{Operational Semantics}
%  \label{fig:operational-semantics}
%\end{figure}

\subsection{Type Assignment}
\label{sec:type-assignment}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[T-Field]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}\\
      \entails{\ovl{c}, \ovl{a}}{\instanceOf{x.f}{C}}\\\\
      \entails{\ovl{c}, \ovl{a}, \pathEq{x.f}{y}}{\ovl{b}}\\
      x \not \in \mIt{FV}(\ovl{b})
    }{
      \typeass{\ovl{c}}{e.f}{\type{y}{\ovl{b}}}
    }
    \and
    \inferrule[T-Call]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}\\
      \pair{\ovl{a'}}{\ovl{b}} \in \mIt{MType}(m, x, y)\\\\
      \entails{\ovl{c}, \ovl{a}}{\ovl{a'}}\\
      \entails{\ovl{c}, \ovl{a}, \ovl{b}}{\ovl{b'}}\\
      x \not \in \mIt{FV}(\ovl{b'})
    }{
      \typeass{\ovl{c}}{m(e)}{\type{y}{\ovl{b'}}}
    }
    \and
    \inferrule[T-Var]{
      \entails{\ovl{c}}{\instanceOf{x}{C}}
    }{
      \typeass{\ovl{c}}{x}{\type{y}{\pathEq{y}{x}}}
    }
    \and
    \inferrule[T-Sub]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a'}}}\\\\
      \entails{\ovl{c},\ovl{a'}}{\ovl{a}}
    }{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}
    }
    \and
    \inferrule[T-New]{
      \forall i.~\typeass{\ovl{c}}{e_i}{\type{x_i}{\ovl{a_i}}}\\\\
      \ovl{b} = (\instantiatedBy{x}{C}), \cup_{i} \ovl{a_i}_{\sub{x_i}{x.f_i}}\\\\
      \constructorDeclaration{C}{x}{\ovl{b'}} \in P\\
      \entails{\ovl{c}, \ovl{b}}{\ovl{b'}}
    }{
      \typeass{\ovl{c}}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{e}}}}{\type{x}{\ovl{b}}}
    }
  \end{mathpar}
%  \caption{Type Assignment}
%  \label{fig:type-assignment}
%\end{figure}

\subsection{Type Checking}
\label{sec:type-checking}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[WF-CD]{
      \mIt{FV}(\ovl{a}) = \{ x \}
    }{
      \wf{\constructorDeclaration{C}{x}{\ovl{a}}}
    }
    \and
    \inferrule[WF-MS]{
      \mIt{FV}(\ovl{a}) = \{ x \}\\
      \mIt{FV}(\ovl{b}) = \{ x, y \}
    }{
      \wf{\abstractMethodDeclaration{m}{x}{\ovl{a}}{\type{y}{\ovl{b}}}}
    }
    \and
    \inferrule[WF-RD]{
      \mIt{FV}(\ovl{a}) = \{ x \}\\
      \instanceOf{x}{C'} \in \ovl{a}
    }{
      \wf{\programEntailment{x}{\ovl{a}}{\instanceOf{x}{C}}}
    }
    \and
    \inferrule[WF-MI]{
      \mIt{FV}(\ovl{a}) = \{ x \}\\
      \mIt{FV}(\ovl{b}) = \{ x, y \}\\
      \typeass{\ovl{a}}{e}{\type{y}{\ovl{b}}}
    }{
      \wf{\methodImplementation{m}{x}{\ovl{a}}{\type{y}{\ovl{b}}}{e}}
    }
    \and
    \inferrule[WF-Prog]{
      \forall D \in P.~\wf{D}\\
      \forall m.~\forall \pair{\ovl{a}}{\ovl{b}}, \pair{\ovl{a'}}{\ovl{b'}} \in \mIt{MType}(m, x, y).~\ovl{b}=\ovl{b'}\\
      \forall m.~\forall \pair{\ovl{a}}{\ovl{b}} \in \mIt{MType}(m, x, y).~\mathrm{complete}(m, \type{x}{\ovl{a}})\\
      \forall m. \mathrm{unique}(m)
    }{
      \wf{P}
    }
  \end{mathpar}
%  \caption{Type Checking}
%  \label{fig:type-checking}
%\end{figure}

\subsection{Example Program}
\label{sec:natural-numbers-program}
\begin{align*}
  &\constructorDeclaration{\Zero}{x}{\epsilon}\\
  &\constructorDeclaration{\Succ}{x}{\instanceOf{x.p}{\Nat}}\\
  &\programEntailment{x}{\instanceOf{x}{\Zero}}{\instanceOf{x}{\Nat}}\\
  &\programEntailment{x}{\instanceOf{x}{\Succ}, \instanceOf{x.p}{\Nat}}{\instanceOf{x}{\Nat}}\\
  &\abstractMethodDeclaration{\mathtt{prev}}{x}{\instanceOf{x}{\Nat}}{\type{y}{\instanceOf{y}{\Nat}}}\\
  &\methodImplementation{\mathtt{prev}}{x}{\instanceOf{x}{\Zero}}{\type{y}{\instanceOf{y}{\Nat}}}{\objConstr{\Zero}{}}\\
  &\methodImplementation{\mathtt{prev}}{x}{\instanceOf{x}{\Succ}, \instanceOf{x.p}{\Nat}}{\type{y}{\instanceOf{y}{\Nat}}}{x.p}
\end{align*}

\newpage
%
\section{An Implementation}
% \todo[inline]{%
%   - interpreter for operational semantics\\
%   - type inference for type assignments for expressions\\
%   - type checking through inferring type and check subtype with annotated/expected type\\
%   - constraint entailment via SMT solving
% }
%One of our main goals is to provide an implementation for DCC. % TODO: what is/are the other/s? extend DCC?
We provide an implementation of
\begin{itemize}
  \item the constraint entailment,
  \item the operational semantics,
  \item the type assignment and
  \item the type checking excepting the completeness- and unique check for programs.
\end{itemize}

The implementation of the operational semantics is straightforward and resembles
the rules as seen in \Cref{sec:operational-semantics}.

The implementation of type assignment infers a suitable type for a given expression
(based on the rules of \Cref{sec:type-assignment}).
Checking if a given expression has a suspected type is done via
first inferring a type for the expression and then checking if the inferred type
is a subtype of the suspected type (rule T-Sub).

The implementation of type checking (well-formedness, \Cref{sec:type-checking}) is straightforward,
with the limitation that we skip the completeness- and unique check for programs.

Our approach for the implementation of the constraint entailment rules
from \Cref{sec:constraint-entailment} is to use a SMT solver to solve the constraint system,
s.t. for each entailment to solve we make a query to the solver.
This requires us to provide an encoding of the rules into (first-order) logic
to feed as input into the solver.

The code can be found in the
\href{https://github.com/stg-tud/dep-classes-smt/tree/master/paper/dep-classes/implementation}{
  dep-classes-smt
} github repo.

\section{Towards an SMT encoding}
% \todo[inline]{%
%   - idea (of master thesis): use smt solver\\
%   - first approach: resemble syntax based reasoning to stay close to \Cref{sec:constraint-entailment}\\
%     - unefficient (massive amount of ADTs and recursion needed, not what a SMT solver is good at)\\
%     - multiple infinite domains with ADTs\\
%   - second approach: use semantic reasoning, encode into FO with constraints being simple boolean predicates\\
%     - infinite datatypes are problematic, we will never be able to reject an entailment\\
%   - put solver limitations subsection here?\\
%   - third approach: get rid of the infinite structures\\
%     - limit path depth\\
%     - decidable encoding, we could just finitely enumerate all quantifiers\\
%   - 4th approach: ground encoding to see if it's more efficient\\
% }
Since we want to use a SMT solver for solving constraint entailments we need to
encode the calculus into (first-order) logic.
Creating this encoding is an iterative process for which we sketch the individual steps
we did.

Our first approach was to resemble the syntactic-reasoning of the sequent calculus (\ref{sec:constraint-entailment}) with the encoding.
For this we defined ADTs for the three constraint types as well as for paths and lists
and we used strings for representing variables, fields and classes.
This enabled us to encode the calculus rules in a highly computational form,
which made extensive use of recursive definitions ranging over the ADTs.
This performed badly. We were able to successfully show simple valid entailments,
but the solver gave up and returned \unknown~on more complex valid entailments.
Also the solver was not able to reject invalid entailments.

\begin{figure}[ht]
  \begin{align*}
    % &\Variable ::= ...\\
    % &\Field ::= ...\\
    &\Path ::= \Variable \mid \Path.\Field\\
    % &{\_}_{\sub{}{}}\!\!: \Path \times \Variable \times \Path \rightarrow \Path\\
    &\subst{p}{x}{q} := p \match~\{\\
    &\quad \case{x}{\ite{(p=x)}{q}{p}}\\
    &\quad \case{p'.f}{\subst{p'}{x}{q}.f}\\
    &\}\\
    % C-Subst: instOf
    % &\forall \sortedVar{p}{\Path}, \sortedVar{c}{\Class}, \sortedVar{r}{\Path}, \sortedVar{s}{\Path}, \sortedVar{x}{\Variable}.\\
    &\forall p,c,r,s,x.\\
    &\quad \instOf{p_{\sub{x}{r}}}{c} \land \pathEq{s}{r} \rightarrow\\
    &\qquad \instOf{p_{\sub{x}{s}}}{c}
  \end{align*}
  \caption{Excerpt of Semantics Based Encoding with Computive Substitution}
  \label{fig:semantic-entailment-excerpt}
\end{figure}

As it turned out, relying on the SMT solver to perform multiple recursive computations is problematic.
Hence we want to use a more semantics based approach of reasoning.
So instead of having lists of constraints which where instantiations of an ADT,
we want to employ simple boolean reasoning.
For this we transform the ADTs of the three constraint types into boolean predicates
and keep them unspecified. We also turn classes and fields and variables into enumeration types
as they are known from the context of the entailment to check and the program,
but we keep the ADT for paths as we still need it for computing substitutions.
An excerpt of this is shown in \Cref{fig:semantic-entailment-excerpt}.

This improved the capability to accept valid entailments,
but the solver is still not able to reject invalid entailments.

% \paragraph{SMT Solver Limitations}
% Dealing with quantifiers and recursive definitions is hard for SMT solvers.
% Since SMT solvers do not use induction, proving any property that requires induction
% will fail if we want to use an off-the-shelf SMT solver.
% We might encounter a counterexample during unrolling of the recursive definitions,
% but if none exists we will get looping behaviour during e-matching.

\section{SMT solver limitations}
\label{sec:smt-limitations}
% \todo[inline]{%
%   - recursion + quantifiers + infinite (abstractt) datatypes bad\\
%   - implications of this (see stack overflow answer)\\
%     - the encoding won't be able to accept a query,
%       as it could just unroll the recusive definitions once more and might encounter a counterexample
%       (infinite domain)\\
%     - but it might find a solution to reject a query, as it might encounter a counterexample\\ 
%   - need to limit the use of them
% }
Dealing with quantifiers and recursive definitions is hard for SMT solvers.
Since SMT solvers do not use induction, proving any property that requires induction
will fail if we want to use an off-the-shelf SMT solver.
We might encounter a counterexample during unrolling of the recursive definitions,
but if none exists we will get looping behaviour during e-matching.

\section{Path Depth Limit Encoding}
% \todo[inline]{%
%   - avoid problems identified in SMT limitations\\
%   - need to get rid of the infinite domain of PATHS as well as avoid recursive computations in the solver\\
%   - idea: set a maximum path depth limit (the max amount of which a path might be expanded)\\
%     - e.g.: if the depth limit is set to 1, path x.f is within the limit while x.f.g is not.\\
%     - with the depth limit in place we can now enumerate all possible paths\\
%   - until now: we did rely on the solver to compute path substitutions\\
%   - this cannot be cleanly transformed with the path enumeration type\\
%     - also we want to avoid encoding recursive functions into the SMT solver\\
%   - the enumeration type however allows us to transform the computive substitution function into a predicate\\
%     - we can even compute all the cases in which this predicate will be true externally,
%       thus not relying on the solver for these computations anymore\\
%     - substitution function signature: $\Path \times \Variable \times \Path \times \Path$\\
%     - for $\mIt{substitute}(p,x,q,r)$ we write $\subst{p}{x}{q}=r$\\
%   - the quantifiers encoding the rules need to be updated to the new substitution style\\
%     - we need to check if the Substitution predicate holds in the lhs of the implications\\
%   %this is for a possibly later decidability section
%   - decidability of path depth encoding:\\
%     - all declared datatypes have a finite domain\\
%     - all quantifiers range over variables from the declared datatypes\\
%     - the encoding is decidable as we can finitely enumerate the quantifiers\\
%   - decidability of the ground path depth encoding:\\
%     - all declared datatypes have a finite domain\\
%     - the encoding is quantifier free\\
%     - hence, trivially decidable
% }

As mentioned in \Cref{sec:smt-limitations}, the use of recursive definitions in the encoding has
the effect that the SMT solver will in general not be able to find a solution.
The recusive definitions that remain in the encoding are the path datatype (infinite domain)
and the computation of substitutions.
The idea to get rid of these is to set a limit to the path depth,
meaning a restricting to witch point paths might be expanded.
E.g. if we set the depth limit to one the path $\mathtt{x.f}$ would be within the limit while
$\mathtt{x.f.g}$ would exceed the limit.
With a limit on the maximum path depth in place we can enumerate all possible paths
and transform the path datatype from an ADT to an enumeration type.

Until now we relied on the SMT solver to compute substitutions, but
the path enumeration type allows us to change how we deal with substitutions.
We can now transform the computive substitution function into a boolean predicate,
like we did with the constraints.
We define the predicate with the signature:
\[ \mIt{substitute}: \Path \times \Variable \times \Path \times \Path \]
For $\mIt{substitute}(p, x, q, r)$ we write $\subst{p}{x}{q}=r$,
giving us the notion that the predicate should be true if $r$ is the result
of the substitution of $x$ with $q$ in $p$.

Since all existing paths are now known prior to the solver,
we can compute each possible substitution externally and define the substitution predicate
to be true for exactly these inputs.

The quantified calculus rules need to be updated to respect the new substitution style,
e.g. we must check for correct substitutions in the premise of the rule.
This transformation is shown in \Cref{fig:path-depth-limit-encoding-excerpt}.

\begin{figure}[ht]
  \begin{align*}
    &\Path := \{ x, y \}\\
    &\subst{p}{v}{q} = s :=\\
    &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{y} \land s=\mathtt{y})~\lor\\
    &\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{y} \land s=\mathtt{x})~\lor\\
    &\quad (p=\mathtt{y} \land v=\mathtt{x} \land q=\mathtt{x} \land s=\mathtt{x})~\lor\\
    &\quad (p=\mathtt{y} \land v=\mathtt{y} \land q=\mathtt{x} \land s=\mathtt{y})~\lor\\
    &\quad ...\\
    % C-Subst: instOf
    &\forall p, c, v, r, s, a, b.\\
    &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land\\
    &\quad \instOf{a}{c} \land
          \subst{p}{v}{s}=b\\
    &\qquad \rightarrow \instOf{b}{c}
  \end{align*}
  \caption{Encoding Excerpt with Enumerated Paths}
  \label{fig:path-depth-limit-encoding-excerpt}
\end{figure}

\subsection{Rule C-Prog}
% \todo[inline]{%
%   - C-Prog rule needs to be enumerated\\
%   - this is because the rule instantiates a declaration from the program\\
%   - this declaration introduces a variable and the rule would need to substitute this variable with a path\\
%   - since this variable introduced through the declaration
%     is not (neccecarily) part of the variables valid in the entailment context,
%     we cannot defer this substitution check to the SMT solver\\
%     - as this would require us to add the variable to be a possible variable for the entailment
%       and to be a valid path\\
%     - but it only is a intermediate variable used in the declaration and should not be present anywhere else\\
%   - so we need to compute the result of this substitution prior to the solver\\
%   - which is possible, since all valid paths are known a priory\\
%   - show C-Prog template
% }
With the path depth limit in place, we need to enumerate the C-Prog rule.
This is because the rule instantiates a declaration of the program
and this declaration introduces a variable that gets substituted in the rule.
We cannot defer the substitution check to the SMT solver (like we did in the other rules),
since the variable introduced by the declaration is only used as an intermediate value.
This variable should therefore not be present outside of this rule,
but having the substitution check in the solver would require exactly this.

This requires us to compute the substitution (think of it as intantiating the declaration with a concrete path)
prior to the solver, which is possible since all valid paths are known a priori.

% \todo[inline]{C-Prog rule template}

\subsection{Decidability}
\label{sec:smt-depth-limit-decidability}
% \todo[inline]{%
%   - decidability of path depth encoding:\\
%     - all declared datatypes have a finite domain\\
%     - all quantifiers range over variables from the declared datatypes\\
%     - the encoding is decidable as we can finitely enumerate the quantifiers\\
% }
The encoding is decidable since we can finitely enumerate the quantifiers,
as all quantified variables range over a finite domain.
This is because all declared datatypes are enumeration types
with a finite amount of constructors and all quantified variables
range over one of the declared enumeration types.

\newpage
%
\subsection{Example Encoding}
Assume the natural numbers program from \Cref{sec:natural-numbers-program}.
We want to encode
\[ \entails{\instBy{x}{\Succ}, \instBy{x.p}{\Zero}, \pathEq{x}{y}}{\instOf{y}{\Nat}} \]
using a depth limit of $1$.
\begin{align}
  &\Variable := \{\mathtt{x}, \mathtt{y}\}\\
  &\Class := \{\Zero,\Succ,\Nat\}\\
  &\Path := \{\mathtt{x}, \mathtt{x}.\mathtt{p}, \mathtt{y}, \mathtt{y}.\mathtt{p}\}\\
  % def subst
  &\subst{p}{v}{q} = s :=\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{x} \land s=\mathtt{x})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{x.p} \land s=\mathtt{x.p})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{y} \land s=\mathtt{y})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{y.p} \land s=\mathtt{y.p})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{x} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{x.p} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{y} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{y.p} \land s=\mathtt{x})~\lor\\
  &\quad (p=\mathtt{x.p} \land v=\mathtt{x} \land q=\mathtt{x} \land s=\mathtt{x.p})~\lor\\
  &\quad (p=\mathtt{x.p} \land v=\mathtt{x} \land q=\mathtt{y} \land s=\mathtt{y.p})~\lor\\
  &\quad~...\\
  % C-Refl
  &\forall p.~\pathEq{p}{p} && \text{(C-Refl)}\\
  % C-Class
  &\forall p, c.~\instBy{p}{c} \rightarrow \instOf{p}{c} && \text{(C-Class)}\\
  % C-Subst: pathEq
  &\forall p, q, v, r, s, a, b, c, d. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a \land \subst{q}{v}{r}=b~\land\\
  &\quad \pathEq{a}{b} \land
         \subst{p}{v}{s}=c \land \subst{q}{v}{s}=d\\
  &\qquad \rightarrow \pathEq{c}{d}\\
  % C-Subst: instOf
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land\\
  &\quad \instOf{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instOf{b}{c}\\
  % C-Subst: instBy
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land\\
  &\quad \instBy{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instBy{b}{c}\\
  % C-Prog
  &\instOf{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x}}{\Succ} \land \instOf{\mathtt{x.p}}{\Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Zero} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y.p}}{\Zero} \rightarrow \instOf{\mathtt{y.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Succ} \land \instOf{\mathtt{y.p}}{\Nat} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  % Entailment
  &\neg (\instBy{\mathtt{x}}{\Succ} \land \instBy{\mathtt{x.p}}{\Zero} \land \pathEq{\mathtt{x}}{\mathtt{y}} \rightarrow \instOf{\mathtt{y}}{\Nat})
\end{align}

\section{Grounding the Path Depth Limit Encoding}
% \todo[inline]{%
%   - goal: get a quantifier free encoding s.t. we can use one of the QF theories (and maybe even a different solver)\\
%   - approach: as discussed in the decidability section of the path depth limit encoding we can\\
%     - finitely enumerate the quantified variables\\
%   - put observations about substitution before the final encoding example\\
%   - with the observations about Substitution from the previous section
%     we can remove the substitution predicate from the encoding altogether\\
%   - also we only instantiate the quantifiers with interpretations that fulfill the substitution predicate\\
%   - this removes the complexity of the encoding,
%     as the solver doesnt have to check if the predicate holds for each individual assert
%     as well as reducing the overall number of assertions
% }
With the Path Depth Limit we have a (assumed) decidable encoding,
but we are still using quantifiers.
An idea is to ground the encoding.
This could result in a better solving performance,
as having quantifiers in the encoding
and therefore needing to utilize quantifier instantiation
in the solver adds complexity.
Instead, using a quantifier free encoding might be beneficial.
It might also enable us to employ additional optimizations.

As discussed in \Cref{sec:smt-depth-limit-decidability} it is possible
to finitely enumerate all quantified variables.
So our first approach to ground the encoding is to do exactly this
and assert each single quantifier instantiation in a big conjunction.

\paragraph{Example}
\label{ex:smt-ground-instantiation}
Given the rule for substitutions over instance-of constraints
(see \Cref{fig:path-depth-limit-encoding-excerpt}),
we instantiate the rule for each combination of paths $p,r,s,a,b$,
variables $v$ and classes $c$ to obtain a ground formula.
Assume $p=r=s=b=\mathtt{x}$, $v=a=\mathtt{y}$ for some class $\mathtt{C}$,
we obtain the instantiation:
%
\begin{align*}
  &\pathEq{\mathtt{x}}{\mathtt{x}} \land \subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{y}~\land
  \instOf{\mathtt{y}}{\mathtt{C}} \land \subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{x}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\mathtt{C}}
\end{align*}

\subsection{Substitution in the Ground Encoding}
If we inspect the previous example,
we can make the following observations:
\begin{enumerate}
  \item Some of the substitution checks will be statically known to be false and
  \item all substitution checks can be statically decided.
\end{enumerate}

The previous example is an instantiation of the rule:
\begin{align*}
  % C-Subst: instOf
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land
         \instOf{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instOf{b}{c}
\end{align*}
The substitution check marked in red is statically/externally known to be false
and the one marked in blue is known to be true.
%
\begin{align*}
  % C-Subst: instOf
  &\pathEq{\mathtt{x}}{\mathtt{x}} \land {\color{red}\subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{y}}~\land
  \instOf{\mathtt{y}}{\mathtt{C}} \land {\color{blue}\subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{x}}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\mathtt{C}}
\end{align*}
%
From this we can conclude that this instantiation will never be used
in prvoing the property $\instanceOf{\mathtt{x}}{\mathtt{C}}$,
as the premise of the implication can never be fulfilled.

By inspecting another instantiation of the same rule,
e.g. with
$p=\mathtt{x}, v=\mathtt{x}, r=\mathtt{y}, a=\mathtt{y}, s=\mathtt{x}, b=\mathtt{x}, c=\mathtt{C}$
we obtain the formula:
\begin{align*}
  % C-Subst: instOf
  &\pathEq{\mathtt{x}}{\mathtt{y}} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{y}}=\mathtt{y}}~\land
   \instOf{\mathtt{y}}{\mathtt{C}} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{x}}=\mathtt{x}}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\mathtt{C}}
\end{align*}
In this instantiation both substitution checks are known to be true
and the rule might be usable in proving that $\instanceOf{\mathtt{x}}{\mathtt{C}}$.

With these observations we can modify the ground encoding as follows:
\begin{enumerate}
  \item We do not have to include formulae in the encoding that are not helping in showing a property.
        E.g. where the premise of an implication is known to be false.
  \item Since we can statically decide all substitution checks,
        we do not have to encode the substitution predicate.
        This is in synergy with the previous point,
        as removing the checks in the implications gets possible
        if we only add those formulae where the checks
        are guaranteed to be true.
\end{enumerate}

These changes reduce the complexity for the SMT solver as well as for the
generation of the query to be sent to the solver (preprocessing).
The SMT solver complexity is reduced through two steps.
(1) The removal of the substitution predicate removed the need for
the solver to check and
(2) the total amount of possibilities to check is lowered,
since the rules sent to the solver only include those cases where the
substitution check would have been true.

The reduction in complexity in the preprocessing is mainly due to the fact
that we do not have to generate the definition for the substitution predicate anymore,
which involved iterating over the cross product of the input parameters.

\paragraph{Example}
If we consider the two shown example instantiations, we would only take the second one
\begin{align*}
  % C-Subst: instOf
  &\pathEq{\mathtt{x}}{\mathtt{y}} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{y}}=\mathtt{y}}~\land
   \instOf{\mathtt{y}}{\mathtt{C}} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{x}}=\mathtt{x}}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\mathtt{C}}
\end{align*}
which with the mentioned modifications turns into the formula
\[
  \pathEq{\mathtt{x}}{\mathtt{y}} \land \instOf{\mathtt{y}}{\mathtt{C}} \rightarrow \instOf{\mathtt{x}}{\mathtt{C}}
\]

\subsection{Decidability}
% \todo[inline]{%
%   - decidability of the ground path depth encoding:\\
%     - all declared datatypes have a finite domain\\
%     - the encoding is quantifier free\\
%     - hence, trivially decidable
% }
The encoding is decidable,
as all declared datatypes have a finite domain
and the encoding is quantifier free.

\newpage
%
\subsection{Example Encoding}
Assume the program of natural numbers given in \Cref{sec:natural-numbers-program}.
We want to encode
\[ \entails{\instBy{x}{\Succ}, \instBy{x.p}{\Zero}, \pathEq{x}{y}}{\instOf{y}{\Nat}} \]
using a path depth limit of $1$.
\setcounter{equation}{0}
% Alternatively for each align block
% \usepackage{etoolbox}
% \AtBeginEnvironment{align}{\setcounter{equation}{0}}
\begin{align}
  &\texttt{\Variable} := \{\mathtt{x}, \mathtt{y}\}\\
  &\texttt{\Class} := \{\Zero,\Succ,\Nat\}\\
  &\texttt{\Path} := \{\mathtt{x}, \mathtt{x.p}, \mathtt{y}, \mathtt{y.p}\}\\
  % C-Refl
  &\pathEq{\mathtt{x}}{\mathtt{x}} \land
  \pathEq{\mathtt{x.p}}{\mathtt{x.p}} \land
  \pathEq{\mathtt{y}}{\mathtt{y}} \land
  \pathEq{\mathtt{y.p}}{\mathtt{y.p}} && \text{(C-Refl)}\\
  % C-Class
  &\instBy{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Zero} && \text{(C-Class)}\\
  &\instBy{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Zero} && \text{(C-Class)}\\
  & ...  && \text{(C-Class)}\\
  % C-Subst
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \pathEq{\mathtt{y}}{\mathtt{y}} \rightarrow \pathEq{\mathtt{y}}{\mathtt{x}} && \text{(C-Subst)}\\
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \instOf{\mathtt{y}}{Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Subst)}\\
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \instBy{\mathtt{y}}{Nat} \rightarrow \instBy{\mathtt{x}}{\Nat} && \text{(C-Subst)}\\
  & ... && \text{(C-Subst)}\\
  % C-Prog
  &\instOf{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x}}{\Succ} \land \instOf{\mathtt{x.p}}{\Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Zero} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y.p}}{\Zero} \rightarrow \instOf{\mathtt{y.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Succ} \land \instOf{\mathtt{y.p}}{\Nat} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  % Many more
  &...\\
  % Entailment
  &\neg (\instBy{\mathtt{x}}{\Succ} \land
        \instBy{\mathtt{x.p}}{\Zero} \land
        \pathEq{\mathtt{x}}{\mathtt{y}} \rightarrow
          \instOf{y}{\Nat})
\end{align}

\newpage
%
\section{Determining a suitable depth limit}
\label{sec:determine-depth-limit}
% \todo[inline]{%
%   - how do we set the path depth limit s.t. we can find a solution to an entailment if one would exists\\
%   - refer to the algorithmic system\\
%   - and the equivalency between the algorithmic and the declarative system\\
%   - lemma in the algorithmic system defines set of variables that can occur in a proof\\
%   - show lemma/set construction?\\
%   - use this set to determine the max possible depth
% }
We have introduced an encoding that relies on a parameter
that limits the maximum path depth.
How do we set this limit and is it possible to set it such
that the solver finds a solution if one would exists in the sequent calculus.

\begin{lemma}[5.5.16]
  \label{lem:constraint-system-equiv}
  If \wf{P} then \entails{\ovl{a}}{a} iff \entailsA{\ovl{a}}{a}.
\end{lemma}

\begin{lemma}[5.5.1]
  \label{lem:algorithmic-system-decidable}
  \entailsA{\ovl{a}}{a} is decidable.
\end{lemma}

For this, we rely to the algorithmic system and the equivalency
between the algorithmic- and the declarative system (\Cref{lem:constraint-system-equiv})
and the decidability of the algorithmic system (\Cref{lem:algorithmic-system-decidable}).

The proof of \Cref{lem:algorithmic-system-decidable}
defines a set of paths $S''_{\ovl{a};a}$ and proves that
all judgements in the derivation contain only paths from this set.

We use this to set the depth limit parameter for the encoding
of the given entailment to solve.
For this we determine the path $p \in S''_{\ovl{a};a}$ s.t.
\[ \forall p' \in S''_{\ovl{a};a}.~\mIt{depth}(p) \geq \mIt{depth}(p') \]
and set the depth limit used for the encoding to be precisely $\mIt{depth}(p)$.

\section{Algorithmic Symmetry}
\label{sec:algo-symmetry}
As emphasized in \Cref{sec:determine-depth-limit}
we rely on the equivalency between the declarative and the algorithmic system
to set our depth limit for path enumeration
as well as on the decidability of the declarative system to even have such a limit in place.

\begin{lemma}[5.5.15]
  \label{lem:constraints-declarative-implies-algorithmic}
  If \wf{P} and \entails{\ovl{a}}{a} then \entailsA{\ovl{a}}{a}.
\end{lemma}

\begin{theorem}[5.5.1]
  \label{thm:declarative-system-decidable}
  If \wf{P} then derivation of \entails{\ovl{a}}{a} is decidable.
\end{theorem}

The entailment $\entails{\pathEq{a}{b}}{\pathEq{b}{a}}$ is a counterexample
to \Cref{lem:constraints-declarative-implies-algorithmic}
which describes one direction of \Cref{lem:constraint-system-equiv}
and \Cref{thm:declarative-system-decidable}
as it relies on \Cref{lem:constraint-system-equiv}.

\begin{figure}[ht]
  \begin{mathpar}
    \inferrule[CA-Refl]{}{
      \entailsA{\ovl{a}}{\pathEq{p}{p}}
    }
    \and
    \inferrule[CA-Ident]{}{
      \entailsA{\ovl{a}}{a_i}
    }
    \and
    \inferrule[CA-Class]{
      \entailsA{\ovl{a}}{\instantiatedBy{p}{C}}
    }{
      \entailsA{\ovl{a}}{\instanceOf{p}{C}}
    }
    \and
    \inferrule[CA-Prog]{
      \entailsA{\ovl{a}}{\ovl{b}_{\sub{x}{p}}}\\
      p \sqsubset \ovl{a}\\\\
      (\programEntailment{x}{\ovl{b}}{\instanceOf{x}{C}}) \in P
    }{
      \entailsA{\ovl{a}}{\instanceOf{p}{C}}
    }
    \and
    \inferrule[CA-Subst1]{
      p \sqsubset \ovl{a}\\\\
      \entailsA{\ovl{a}}{\instantiatedBy{p}{C}}\\
      \entailsA{\ovl{a}}{\pathEq{p}{p'}}
    }{
      \entailsA{\ovl{a}}{\instantiatedBy{p'}{C}}
    }
    \and
    \inferrule[CA-Subst2]{
      p \sqsubset \ovl{a}\\\\
      \entailsA{\ovl{a}}{\instanceOf{p}{C}}\\
      \entailsA{\ovl{a}}{\pathEq{p}{p'}}
    }{
      \entailsA{\ovl{a}}{\instanceOf{p'}{C}}
    }
    \and
    \inferrule[CA-Subst3]{
      p \sqsubset \ovl{a}\\\\
      \entailsA{\ovl{a}}{\pathEq{p}{p''}}\\
      \entailsA{\ovl{a}}{\pathEq{p'}{p}}
    }{
      \entailsA{\ovl{a}}{\pathEq{p'}{p''}}
    }
    \and
    \inferrule[CA-Subst4]{
      \entailsA{\ovl{a}}{\pathEq{p}{p'}}
    }{
      \entailsA{\ovl{a}}{\pathEq{p.f}{p'.f}}
    }
  \end{mathpar}
  \caption{Algorithmic Rules}
  \label{fig:algorithmic-system}
\end{figure}

\paragraph{Counterexample}
Choose any well-formed program.

The entailment $\entails{\pathEq{a}{b}}{\pathEq{b}{a}}$ has
a derivation in the declarative system.
% how to typeset the rule names to the rhs?
% \begin{mathpar}
%   \inferrule[C-Subst]{
%     \inferrule[C-Weak]{
%       \inferrule[C-Refl]{}{\entails{\cdot}{\pathEq{b}{b}}}
%     }{
%       \entails{\pathEq{a}{b}}{\pathEq{b}{a}_{\sub{a}{b}}}
%     }\\
%     \inferrule[C-Ident]{}{\entails{\pathEq{a}{b}}{\pathEq{a}{b}}}
%   }{
%     \entails{\pathEq{a}{b}}{ \pathEq{b}{a}_{\sub{a}{a}} }
%   }
% \end{mathpar}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{C-Refl}
  \UnaryInfC{\entails{\cdot}{\pathEq{b}{b}}}
  \RightLabel{C-Weak}
  \UnaryInfC{\entails{\pathEq{a}{b}}{ \pathEq{b}{a}_{\sub{a}{b}} }}
  \AxiomC{}
  \RightLabel{C-Ident}
  \UnaryInfC{\entails{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \RightLabel{C-Subst}
  \BinaryInfC{\entails{\pathEq{a}{b}}{\pathEq{b}{a}_{\sub{a}{a}}}}
\end{prooftree}

In the algorithmic system, only rule CA-Subst3 applies.
We have two possible ways to approach this sequent.

\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{a}}}
  \AxiomC{$a \sqsubset \pathEq{a}{b}$}
  \AxiomC{...}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
  \RightLabel{CA-Subst3}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{...}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
  \AxiomC{$b \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{b}}}
  \RightLabel{CA-Subst3}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

We can see that we reproduce the same proof goal
in one of the branches of both possibilities
and we cannot close those branches.

\subsection{Symmetry Fix}
\label{sec:symmetry-fix}
We can update rule CA-Subst3 to allow the entailment used as a counterexample
to \Cref{lem:constraints-declarative-implies-algorithmic} to have a derivation.

There are two feasible ways to update the rule:
\begin{enumerate}
  \item
  \begin{prooftree}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p}{p''}}}
    \AxiomC{$p \sqsubset \ovl{a}$}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p}{p'}}}
    \RightLabel{CA-Subst3Fix1}
    \TrinaryInfC{\entailsA{\ovl{a}}{\pathEq{p'}{p''}}}
  \end{prooftree}
  \item
  \begin{prooftree}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p''}{p}}}
    \AxiomC{$p \sqsubset \ovl{a}$}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p'}{p}}}
    \RightLabel{CA-Subst3Fix2}
    \TrinaryInfC{\entailsA{\ovl{a}}{\pathEq{p'}{p''}}}
  \end{prooftree}
\end{enumerate}

\subsubsection{Fix 1 derivation}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{a}}}
  \AxiomC{$a \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Ident}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \RightLabel{CA-Subst3Fix1}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\subsubsection{Fix 2 derivation}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Ident}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \AxiomC{$b \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{b}}}
  \RightLabel{CA-Subst3Fix2}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\subsubsection{Fix Implications}
% \todo[inline]{%
%   - Termination concerns\\
%     - could just infinitely symmetric switch with CA-Subst3\\
%     - need to limit it, s.t. path equivalencies might only be symmetrically switched once (using a "memory" context?)\\
%     - need some sort of memory anyways, even in the original version, as we could just choose the same path over and over again\\
%       - need to memoize already tested paths per branch
% }
Deploying the update to rule CA-Subst3 might have implications
on the termination of the algorithmic system.
We could e.g. repeatedly apply rule CA-Subst3 to symmetrically switch
a path equivalence.

This can be resolved by having the limitaion that we may apply
a rule using the same parameters at most once per branch.

This seems sensible, as we (most likely) already need this for termination.
Otherwise we would also be allowed to satisfy $p \sqsubset \ovl{a}$ for the same $p$.

% \section{Algorithmic System Implementation}
% \todo[inline]{%
%   - runtime of the algorithmic implementation is presumedly dependent on the order of rule application
%     and order of path picks in satisfing $p \sqsubset \ovl{a}$
%   - order of rule application (without path picks) is most likely not really a problem,
%     as the rules match on different constraint types (is it deterministic?)
%   - implementation memoizes rule applications per branch, in order to terminate
% }
% \wip

%\section{Runtime Comparison}
%add table
%\wip

%\section{Equivalency Proof (declarative/algorithmic system)}
%\wip

\section{Object Construction}
With the rules for type assignment as seen in \Cref{sec:type-assignment}
it is possible to construct objects with more fields than anticipated.
This is because the constructor declaration defines a set of constraints that
need to be fulfilled in order to create a new object, but it is possible to "oversatisfy"
those constraints.

\paragraph{Example}
\begin{prooftree}
  % \AxiomC{\typeass{\instanceOf{x}{\Zero}}{x}{\type{z}{\pathEq{z}{x}}}}
  % ↓ This is not accurate, but with y.p as the binder better understandable of the substitution that happens when constructing b
  \AxiomC{\typeass{\instanceOf{x}{\Zero}}{x}{\type{y.p}{\pathEq{y.p}{x}}}}
  \noLine
  \UnaryInfC{$\constructorDeclaration{\Zero}{y}{\epsilon} \in P$}
  \AxiomC{$\ovl{b} = \instantiatedBy{y}{\Zero}, \pathEq{y.p}{x}$}
  \noLine
  \UnaryInfC{\entails{\instanceOf{x}{\Zero},\ovl{b}}{\epsilon}}
  \RightLabel{T-New}
  \BinaryInfC{\typeass{\instanceOf{x}{\Zero}}{\objConstr{\Zero}{\pathEq{p}{x}}}{\type{y}{\instantiatedBy{y}{\Zero}, \pathEq{y.p}{x}}}}
\end{prooftree}

Since anything entails $\epsilon$, the check for
$\entails{\instanceOf{x}{\Zero}, \instantiatedBy{y}{\Zero}, \pathEq{y.p}{x}}{\epsilon}$
succeeds and we can successfully assign a type for $\objConstr{\Zero}{\pathEq{p}{x}}$,
albeit the constructor for $\Zero$ doesn't constraint any fields.

This is because of the discrepancy between the syntax of object construction $\objConstr{C}{\pathEq{\ovl{f}}{\ovl{e}}}$
and the syntax of constructor declaration $\constructorDeclaration{C}{x}{\ovl{a}}$ and the way they come together
in rule T-New.
In object creation we have a concrete set of fields $\ovl{f}$ we want to assign values to,
while in constructor declaration we only have a set of constraints $\ovl{a}$
that describe the class including it's fields.

In rule T-New we check with $\entails{\ovl{c},\ovl{b}}{\ovl{b'}}$ that we supplied enough fields
to satisfy the constraints of the class, but we do not check the other direction.
Namely that we provide fields that are unknown to the constraints of the constructor.

\subsection{Update to T-New}
We add an additional check to rule T-New that checks if the fields $\ovl{f}$ are
constrained from the constructor.

\begin{mathpar}
  \inferrule[T-New]{
    \forall i.~\typeass{\ovl{c}}{e_i}{\type{x_i}{\ovl{a_i}}}\\
    \ovl{b} = (\instantiatedBy{x}{C}), \cup_{i} \ovl{a_i}_{\sub{x_i}{x.f_i}}\\
      \constructorDeclaration{C}{x}{\ovl{b'}} \in P\\
      \entails{\ovl{c}, \ovl{b}}{\ovl{b'}}\\
      \forall i.~f_i \in \mathsf{FIELDS}(b')
  }{
    \typeass{\ovl{c}}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{e}}}}{\type{x}{\ovl{b}}}
  }
\end{mathpar}

\section{Refinement Types}
Can we relate the DCC system to refinement types and
how does DCCs constraint language compare in terms of expressiveness to what
we expect from refinement types?

Usually refinement types are depicted as $\refT{x}{\tau}{\varphi}$,
where $\tau$ is a type and $\varphi$ is a formula over $x$.

\subsection{Semantics of Refinement Types}
Semantically, such a type is meant to refine the domain of the type $\tau$
with $\varphi$. E.g. the type $\refT{n}{\mathtt{Int}}{n>0}$
refines the domain of all integers to only the strictly positive integers.
\[
  \llbracket \refT{x}{\tau}{\varphi} \rrbracket =
    \{ v | v \in \llbracket\tau\rrbracket \land \varphi_{\sub{x}{v}} \}
\]

\subsection{Connection to DCC}
We can relate multiple constructs from DCC to refinement types,
or at least state that those behave in a similar way to the semantics
refinements expressable with refinement types.

\subsection{Constructor Declaration}
We can think of DCCs constructor declaration as some sort of
refinement of the objects of a class.
E.g. the declaration $\constructorDeclaration{C}{x}{\ovl{a}}$
to semantically express something similar to a potential refinement type
$\refT{x}{C}{\ovl{a}}$.
Refining objects of class $C$ to adhere to $\ovl{a}$.

%\subsection{Methods}

\subsection{What is an Object in DCC?}
% - usually we have object be structure and behaviour
% - in DCC objects during runtime are only structure
% - behaviour in the form of methods are defined "outsite"
% - we only have constructor declarations instead of class declarations
% - an object $\stdobj$ on the heap consists of
%   - a class $C$ the object was constructed from
%   - a list of pairs $\pathEq{f_i}{x_i}$ of the fields of the object
%     and their corresponding memory location on the heap.
%
Objects usually consist of structure (fields) and behaviour (methods).
In DCC objects only consists of structure (fields), while the behaviour (methods)
is declared outside the scope of classes and their objects.
More specific, their are only constructor declarations and method declarations
at the "top level" of the syntax instead of class declarations that encapsulate/incorporate both.
In DCC an object $\stdobj$ on the heap consists of
1) a class $C$ from which the object was constructed from and
2) a list of pairs $\pathEq{f_i}{x_i}$ of the fields of the object
and their corresponding memory location on the heap.

\subsection{Types}
% - A type in DCC $\type{x}{\ovl{a}}$ consists of
%   - an identifier $x$ and
%   - a set of constraints $\ovl{a}$ over $x$.
%   - This type semantically describes all objects that fulfill
%     $\ovl{a}$.
% - This can be seen like a refinement type over objects.
%   - In the "language" of refinement types: $\refT{x}{\mathsf{Object}}{\ovl{a}}$.
%   - Since in DCC we are on the type level only concerned with objects and their structure
%     the types omit the $\tau$ part that refinement types usually incorporate.
%   - We can do this since that actual class an object belongs to (as well as inheritance)
%     is handled through the constraint system.
% - semantically DCCs types behave similar to refinement types
% - \[ \llbracket \type{x}{\ovl{a}} \rrbracket = 
%        \{ o | o \in \mathsf{Object} \land \entails{OC(x,o)}{\ovl{a}} \} \]
% - E.g. $\refT{n}{\mathtt{Int}}{n>0}$ would translate to
%        $\type{n}{\instanceOf{n}{\mathtt{Int}, n>0}}$
%   - ignoring the fact that $n>0$ is not a refinement of the structure of objects
%     and therefore not part of the constraint language used in DCC
%
In DCC a type $\type{x}{\ovl{a}}$ consist of
1) an identifier $x$ and
2) a set of constraints $\ovl{a}$ over $x$.
Semantically, such a type describes all objects
that fulfill constraints $\ovl{a}$.
This can be seen as a refinement type over objects
$\refT{x}{\mathsf{Object}}{\ovl{a}}$.
E.g. $\refT{n}{\mathtt{Int}}{n>0}$ would translate to
$\type{n}{\instanceOf{n}{\mathtt{Int}, n>0}}$,
ignoring the fact that there is a non-structural constraint $n>0$.

Since DCCs types are only concerned with objects and their structure
we omit the $\mathsf{Object}$ type in the type syntax
and instead of a generic formulae $\varphi$
we have a set of constraints $\ovl{a}$.
This is possible, since the class an object belongs to (as well as inheritance)
is handled through the constraint system.
Semantically, a DCC type behaves similar to a refinement type as statet previously and
describes objects that conform to the constraints of the type,
more formally:
\[
  \semantics{\type{x}{\ovl{a}}}{h} = 
    \{ o | o \in \mathsf{Object} \land \entails{HC(h), OC(x,o)}{\ovl{a}} \}
\]
% \[
%   \llbracket \type{x}{\ovl{a}} \rrbracket_{h} = 
%     \{ o | o \in \mathsf{Object} \land \entails{HC(h[\heap{x}{o})]}{\ovl{a}} \}
% \]
where $h$ is a heap under which the type should be evaluated.

\subsection{DCC refinement limitations}
% - refinements in refinement types are usually formulae
% - in DCC we have set of constraints
% - and all of those need to be fulfilled simultaneously
% - this limits refinements in DCC to be a big conjunction
% - interestingly, this is exactly how we translate it in the SMT encoding
%   - $a_1,a_2,...,a_n$ to $a_1 \land a_2 \land ... \land a_n$
%   - more general $\ovl{a}$ to $\bigwedge_i \mathsf{SMT}(a_i)$
%     - if $\ovl{a}=\epsilon$, to $true$
%
Refinement types usually use formulae for their refinement (with varying restrictions).
In DCC we the refinements are limited to a set of (structural) constraints
and all of those need to be fulfilled simultaneously.
This is equivalent to a big conjunction in the language of predicate logic.

Interestingly, this is exactly how the translation in the SMT encoding works.
E.g. a set of constraints $(a_1, a_2, a_3)$ gets translated to
$(\mathsf{SMT}(a_1) \land \mathsf{SMT}(a_2) \land \mathsf{SMT}(a_3))$
or more generally $\ovl{a}$ translates to $\bigwedge_i \mathsf{SMT}(a_i)$.
The empty set of constraints $\epsilon$ translates to $true$.

\subsection{Subtyping}
We can describe the semantic behaviour of subtyping/subsumption.
\[
  c \vdash \type{x}{\ovl{a}} <: \type{x}{\ovl{b}}
  \Leftrightarrow
  \entails{c,b}{a}
\]
\[
  c \vdash \type{x}{\ovl{a}} <: \type{x}{\ovl{b}}
  \Leftrightarrow
  \forall h.~\entails{c}{HC(h)} \land \semantics{\type{x}{\ovl{a}}}{h} \subseteq \semantics{\type{x}{\ovl{b}}}{h}
\]

%E.g. $\type{x}{\instanceOf{x.f}{\Nat}} <: \type{x}{\instanceOf{x.f}{\Nat}, \instanceOf{x.g}{\Nat}}$
%or $\type{x}{\instanceOf{x}{\Zero}} <: \type{x}{\instanceOf{x}{\Nat}}$.

\subsection{future work}
% - extending the expressiveness of the constraints
%   to be more in line with refinement types
% - turn the set of constraints into an actual formulae
%   - allow negation, disjunction, etc
% - add more kinds of constraints to not only have refinements on the structure of objects
%
A possible direction for future work is to extend the expressiveness
of the refinements (constraint system). There are two paths to extend upon:
\begin{enumerate}
  \item transform the strict conjunctive form of the current constraints to
        support a wider range of operations through support for negation etc.
  \item add new kinds of constraints that are not neccecarily structural.
\end{enumerate}

% TODO: look at approx in the thesis
%               5.5.4 Checking Method Completeness and Uniqueness
% TODO: family polymorphism 
% - what is the system practically good for
% TODO: look at examples (unpublished/thesis)
\end{document}
