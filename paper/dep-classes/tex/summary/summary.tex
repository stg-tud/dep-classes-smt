\documentclass[a4paper]{article}

%% packages
%%%%%%%%%%%
\usepackage[utf8x]{inputenc}
\usepackage[USenglish]{babel}
\usepackage{amsbsy,amscd,amsfonts,amssymb,amstext,amsmath,amsthm,latexsym}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{dot2texi}
\usepackage{url}
\usepackage{hyperref}
\usepackage[nottoc]{tocbibind}
\usepackage{pdfpages}

\usepackage{syntax}     % for bnf grammar
\usepackage{bussproofs} % for type rules
\usepackage{todonotes}

\usepackage{float}      % for figures
\floatstyle{boxed}
\restylefloat{figure}

\usepackage{listings}
\usepackage{xcolor}
%\usepackage{tikz}
%\usetikzlibrary{positioning,chains,shapes.arrows,shapes.geometric,fit,calc,arrows,decorations.pathmorphing}

%\usepackage{subfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{cleveref}   % for better references with \Cref
\usepackage{parskip}    % line breaks in texts

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\input{macros}
%\input{tikz}

\begin{document}

\section{Overview}
\section{DCC recap}
\subsection{Syntax}
\label{sec:syntax}
%\begin{figure}[h]
  \begin{align*}
    P &::= \ovl{D} && \text{(Program)}\\
    D &::= \constructorDeclaration{C}{x}{\ovl{a}}
      \mid \programEntailment{x}{\ovl{a}}{a}
      \mid \abstractMethodDeclaration{m}{x}{\ovl{a}}{t}
      \mid \methodImplementation{m}{x}{\ovl{a}}{t}{e} && \text{(Decl)}\\
    t &::= \type{x}{\ovl{a}} && \text{(Type)}\\
    a &::= \pathEq{p}{p}
      \mid \instOf{p}{C}
      \mid \instBy{p}{C} && \text{(Constr)}\\
    p &::= x \mid p.f && \text{(Path)}\\
    e &::= x
      \mid e.f
      \mid \objConstr{C}{\pathEq{\ovl{f}}{\ovl{e}}} && \text{(Expr)}
  \end{align*}
%\caption{DCC Syntax}
%\label{fig:syntax}
%\end{figure}

\subsection{Constraint Entailment}
\label{sec:constraint-entailment}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[C-Ident]{}{
      \entails{a}{a}
    }
    \and
    \inferrule[C-Refl]{}{
      \entails{\epsilon}{\pathEq{p}{p}}
    }
    \and
    \inferrule[C-Class]{
      \entails{\ovl{a}}{\instBy{p}{C}}
    }{
      \entails{\ovl{a}}{\instOf{p}{C}}
    }
    \and
    \inferrule[C-Cut]{
      \entails{\ovl{a}}{c}\\
      \entails{\ovl{a'},c}{b}
    }{
      \entails{\ovl{a},\ovl{a'}}{b}
    }
    \and
    \inferrule[C-Subst]{
      \entails{\ovl{a}}{a_{\sub{x}{p}}}\\
      \entails{\ovl{a}}{\pathEq{p'}{p}}
    }{
      \entails{\ovl{a}}{a_{\sub{x}{p'}}}
    }
    \and
    \inferrule[C-Prog]{
      (\programEntailment{x}{\ovl{a}}{a}) \in P\\
      \entails{\ovl{b}}{\ovl{a}_{\sub{x}{p}}}
    }{
      \entails{\ovl{a}}{a_{\sub{x}{p}}}
    }
  \end{mathpar}
%  \caption{Constraint Entailment}
%  \label{fig:constraint-entailment}
%\end{figure}

\subsection{Operational Semantics}
\label{sec:operational-semantics}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[R-New]{
      x \not \in \mathit{dom}(h)\\
      o = \stdobj\\\\
      \constructorDeclaration{C}{x}{\ovl{b}} \in P\\
      \entails{\mIt{HC}(h), \mIt{OC}(x, o)}{\ovl{b}}
    }{
      \pair{h}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}}} \rightarrow
        \pair{h, x \mapsto o}{x}
    }
    \and
    \inferrule[R-Field]{
      (\pathEq{x.f}{y}) \in \mIt{HC}(h)
    }{
      \pair{h}{x.f} \rightarrow
        \pair{h}{y}
    }
    \and
    \inferrule[R-Call]{
      S = \{ \pair{\ovl{a}}{e} | \pair{\ovl{a}}{e} \in \mIt{mImpl}(m, x) \land \entails{\mIt{HC}(h)}{\ovl{a}} \}\\
      \pair{\ovl{a}}{e} \in S\\
      \forall \pair{\ovl{a'}}{e'} \in S.~(e' \neq e) \longrightarrow \entails{\ovl{a'}}{\ovl{a}} \land \neg \entails{\ovl{a}}{\ovl{a'}}
    }{
      \pair{h}{m(x)} \rightarrow
        \pair{h}{e}
    }
    \and
    \inferrule[RC-Field]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{e.f} \rightarrow
        \pair{h'}{e'.f}
    }
    \and
    \inferrule[RC-Call]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{m(e)} \rightarrow
        \pair{h'}{m(e')}
    }
    \and
    \inferrule[RC-New]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}, \pathEq{f}{e}, \pathEq{\ovl{f'}}{\ovl{e'}}}} \rightarrow
        \pair{h'}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}, \pathEq{f}{e'}, \pathEq{\ovl{f'}}{\ovl{e'}}}}
    }
  \end{mathpar}
%  \caption{Operational Semantics}
%  \label{fig:operational-semantics}
%\end{figure}

\subsection{Type Assignment}
\label{sec:type-assignment}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[T-Field]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}\\
      \entails{\ovl{c}, \ovl{a}}{\instanceOf{x.f}{C}}\\\\
      \entails{\ovl{c}, \ovl{a}, \pathEq{x.f}{y}}{\ovl{b}}\\
      x \not \in \mIt{FV}(\ovl{b})
    }{
      \typeass{\ovl{c}}{e.f}{\type{y}{\ovl{b}}}
    }
    \and
    \inferrule[T-Call]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}\\
      \pair{\ovl{a'}}{\ovl{b}} \in \mIt{MType}(m, x, y)\\\\
      \entails{\ovl{c}, \ovl{a}}{\ovl{a'}}\\
      \entails{\ovl{c}, \ovl{a}, \ovl{b}}{\ovl{b'}}\\
      x \not \in \mIt{FV}(\ovl{b'})
    }{
      \typeass{\ovl{c}}{m(e)}{\type{y}{\ovl{b'}}}
    }
    \and
    \inferrule[T-Var]{
      \entails{\ovl{c}}{\instanceOf{x}{C}}
    }{
      \typeass{\ovl{c}}{x}{\type{y}{\pathEq{y}{x}}}
    }
    \and
    \inferrule[T-Sub]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a'}}}\\\\
      \entails{\ovl{c},\ovl{a'}}{\ovl{a}}
    }{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}
    }
    \and
    \inferrule[T-New]{
      \forall i.~\typeass{\ovl{c}}{e_i}{\type{x_i}{\ovl{a_i}}}\\\\
      \ovl{b} = (\instantiatedBy{x}{C}), \cup_{i} \ovl{a_i}_{\sub{x_i}{x.f_i}}\\\\
      \constructorDeclaration{C}{x}{\ovl{b'}} \in P\\
      \entails{\ovl{c}, \ovl{b}}{\ovl{b'}}
    }{
      \typeass{\ovl{c}}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{e}}}}{\type{x}{\ovl{b}}}
    }
  \end{mathpar}
%  \caption{Type Assignment}
%  \label{fig:type-assignment}
%\end{figure}

\subsection{Type Checking}
\label{sec:type-checking}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[WF-CD]{
      \mIt{FV}(\ovl{a}) = \{ x \}
    }{
      \wf{\constructorDeclaration{C}{x}{\ovl{a}}}
    }
    \and
    \inferrule[WF-MS]{
      \mIt{FV}(\ovl{a}) = \{ x \}\\
      \mIt{FV}(\ovl{b}) = \{ x, y \}
    }{
      \wf{\abstractMethodDeclaration{m}{x}{\ovl{a}}{\type{y}{\ovl{b}}}}
    }
    \and
    \inferrule[WF-RD]{
      \mIt{FV}(\ovl{a}) = \{ x \}\\
      \instanceOf{x}{C'} \in \ovl{a}
    }{
      \wf{\programEntailment{x}{\ovl{a}}{\instanceOf{x}{C}}}
    }
    \and
    \inferrule[WF-MI]{
      \mIt{FV}(\ovl{a}) = \{ x \}\\
      \mIt{FV}(\ovl{b}) = \{ x, y \}\\
      \typeass{\ovl{a}}{e}{\type{y}{\ovl{b}}}
    }{
      \wf{\methodImplementation{m}{x}{\ovl{a}}{\type{y}{\ovl{b}}}{e}}
    }
    \and
    \inferrule[WF-Prog]{
      \forall D \in P.~\wf{D}\\
      \forall m.~\forall \pair{\ovl{a}}{\ovl{b}}, \pair{\ovl{a'}}{\ovl{b'}} \in \mIt{MType}(m, x, y).~\ovl{b}=\ovl{b'}\\
      \forall m.~\forall \pair{\ovl{a}}{\ovl{b}} \in \mIt{MType}(m, x, y).~\mathrm{complete}(m, \type{x}{\ovl{a}})\\
      \forall m. \mathrm{unique}(m)
    }{
      \wf{P}
    }
  \end{mathpar}
%  \caption{Type Checking}
%  \label{fig:type-checking}
%\end{figure}

\section{An Implementation}
% \todo[inline]{%
%   - interpreter for operational semantics\\
%   - type inference for type assignments for expressions\\
%   - type checking through inferring type and check subtype with annotated/expected type\\
%   - constraint entailment via SMT solving
% }

%One of our main goals is to provide an implementation for DCC. % TODO: what is/are the other/s? extend DCC?
We provide an implementation of
\begin{itemize}
  \item the constraint entailment,
  \item the operational semantics,
  \item the type assignment and
  \item the type checking excepting the completeness- and unique check for programs.
\end{itemize}

The implementation of the operational semantics is straightforward and resembles
the rules as seen in \Cref{sec:operational-semantics}.

The implementation of type assignment infers a suitable type for a given expression
(based on the rules of \Cref{sec:type-assignment}).
Checking if a given expression has a suspected type is done via
first inferring a type for the expression and then checking if the inferred type
is a subtype of the suspected type (rule T-Sub).

The implementation of type checking (well-formedness, \Cref{sec:type-checking}) is straightforward,
with the limitation that we skip the completeness- and unique check for programs.

Our approach for the implementation of the constraint entailment rules
from \Cref{sec:constraint-entailment} is to use a SMT solver to solve the constraint system,
s.t. for each entailment to solve we make a query to the solver.
This requires us to provide an encoding of the rules into (first-order) logic
to feed as input into the solver.

\section{Towards an SMT encoding}
\todo[inline]{%
  - idea (of master thesis): use smt solver\\
  - first approach: resemble syntax based reasoning to stay close to \Cref{sec:constraint-entailment}\\
    - unefficient (massive amount of ADTs and recursion needed, not what a SMT solver is good at)\\
    - multiple infinite domains with ADTs\\
  - second approach: use semantic reasoning, encode into FO with constraints being simple boolean predicates\\
    - infinite datatypes are problematic, we will never be able to reject an entailment\\
  - put solver limitations subsection here?\\
  - third approach: get rid of the infinite structures\\
    - limit path depth\\
    - decidable encoding, we could just finitely enumerate all quantifiers\\
  - 4th approach: ground encoding to see if it's more efficient\\
}
Since we want to use a SMT solver for solving constraint entailments we need to
encode the calculus into (first-order) logic.
Creating this encoding is an iterative process for which we sketch the individual steps
we did:
% dont do this with an enumeration, instead use multiple paragraphs
% this would also allow the limitations section to be insertet inbetween
\begin{enumerate}
  \item \todo{TODO}
\end{enumerate}

\section{SMT solver limitations}
\todo[inline]{%
  - recursion + quantifiers + infinite (abstractt) datatypes bad\\
  - need to limit the use of them
}

\section{Path Depth Limit Encoding}
\todo[inline]{%
  - avoid problems identified in SMT limitations\\
  - need to get rid of the infinite domain of PATHS as well as avoid recursive computations in the solver\\
  - idea: set a maximum path depth limit (the max amount of which a path might be expanded)\\
    - e.g.: if the depth limit is set to 1, path x.f is within the limit while x.f.g is not.\\
    - with the depth limit in place we can now enumerate all possible paths\\
  - until now: we did rely on the solver to compute path substitutions\\
  - this cannot be cleanly transformed with the path enumeration type\\
    - also we want to avoid encoding recursive functions into the SMT solver\\
  - the enumeration type however allows us to transform the computive substitution function into a predicate\\
    - we can even compute all the cases in which this predicate will be true externally,
      thus not relying on the solver for these computations anymore\\
    - substitution function signature: $\Path \times \Variable \times \Path \times \Path$\\
    - for $\mIt{substitute}(p,x,q,r)$ we write $\subst{p}{x}{q}=s$\\
  - the quantifiers encoding the rules need to be updated to the new substitution style\\
    - we need to check if the Substitution predicate holds in the lhs of the implications\\
  % this is for a possibly later decidability section
  - decidability of path depth encoding:\\
    - all declared datatypes have a finite domain\\
    - all quantifiers range over variables from the declared datatypes\\
    - the encoding is decidable as we can finitely enumerate the quantifiers\\
  - decidability of the ground path depth encoding:\\
    - all declared datatypes have a finite domain\\
    - the encoding is quantifier free\\
    - hence, trivially decidable
}

\subsection{Example Encoding}
To encode: $\entails{\instBy{x}{\Succ}, \instBy{x.p}{\Zero}, \pathEq{x}{y}}{\instOf{y}{\Nat}}$
with $\mathit{depth\!\!-\!\!limit}=1$
\begin{align}
  &\texttt{\Variable} := \{\mathtt{x}, \mathtt{y}\}\\
  &\texttt{\Class} := \{\Zero,\Succ,\Nat\}\\
  &\texttt{\Path} := \{\mathtt{x}, \mathtt{x}.\mathtt{p}, \mathtt{y}, \mathtt{y}.\mathtt{p}\}\\
  % def subst
  &\subst{p}{v}{q} = s :=\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{x} \land s=\mathtt{x})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{x.p} \land s=\mathtt{x.p})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{y} \land s=\mathtt{y})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{y.p} \land s=\mathtt{y.p})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{x} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{x.p} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{y} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{y.p} \land s=\mathtt{x})~\lor\\
  &\quad (p=\mathtt{x.p} \land v=\mathtt{x} \land q=\mathtt{x} \land s=\mathtt{x.p})~\lor\\
  &\quad (p=\mathtt{x.p} \land v=\mathtt{x} \land q=\mathtt{y} \land s=\mathtt{y.p})~\lor\\
  &\quad~...\\
  % C-Refl
  &\forall p.~\pathEq{p}{p} && \text{(C-Refl)}\\
  % C-Class
  &\forall p, c.~\instBy{p}{c} \rightarrow \instOf{p}{c} && \text{(C-Class)}\\
  % C-Subst: pathEq
  &\forall p, q, v, r, s, a, b, c, d. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a \land \subst{q}{v}{r}=b~\land\\
  &\quad \pathEq{a}{b} \land
         \subst{p}{v}{s}=c \land \subst{q}{v}{s}=d\\
  &\qquad \rightarrow \pathEq{c}{d}\\
  % C-Subst: instOf
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land\\
  &\quad \instOf{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instOf{b}{c}\\
  % C-Subst: instBy
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land\\
  &\quad \instBy{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instBy{b}{c}\\
  % C-Prog
  &\instOf{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x}}{\Succ} \land \instOf{\mathtt{x.p}}{\Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Zero} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y.p}}{\Zero} \rightarrow \instOf{\mathtt{y.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Succ} \land \instOf{\mathtt{y.p}}{\Nat} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  % Entailment
  &\neg (\instBy{\mathtt{x}}{\Succ} \land \instBy{\mathtt{x.p}}{\Zero} \land \pathEq{\mathtt{x}}{\mathtt{y}} \rightarrow \instOf{\mathtt{y}}{\Nat})
\end{align}

\subsection{Decidability}
\todo[inline]{%
  - decidability of path depth encoding:\\
    - all declared datatypes have a finite domain\\
    - all quantifiers range over variables from the declared datatypes\\
    - the encoding is decidable as we can finitely enumerate the quantifiers\\
}

\newpage

\section{Grounding the Path Depth Limit Encoding}
\todo[inline]{%
  - goal: get a quantifier free encoding s.t. we can use one of the QF theories (and maybe even a different solver)\\
  - approach: as discussed in the decidability section of the path depth limit encoding we can\\
    - finitely enumerate the quantified variables\\
  - put observations about substitution before the final encoding example\\
  - with the observations about Substitution from the previous section
    we can remove the substitution predicate from the encoding altogether\\
  - also we only instantiate the quantifiers with interpretations that fulfill the substitution predicate\\
  - this removes the complexity of the encoding,
    as the solver doesnt have to check if the predicate holds for each individual assert
    as well as reducing the overall number of assertions
}

\subsection{Example Encoding}
To encode: $\entails{\instBy{x}{\Succ}, \instBy{x.p}{\Zero}, \pathEq{x}{y}}{\instOf{y}{\Nat}}$
with $\mathit{depth\!\!-\!\!limit}=1$
\setcounter{equation}{0}
% Alternatively for each align block
% \usepackage{etoolbox}
% \AtBeginEnvironment{align}{\setcounter{equation}{0}}
\begin{align}
  &\texttt{\Variable} := \{\mathtt{x}, \mathtt{y}\}\\
  &\texttt{\Class} := \{\Zero,\Succ,\Nat\}\\
  &\texttt{\Path} := \{\mathtt{x}, \mathtt{x.p}, \mathtt{y}, \mathtt{y.p}\}\\
  % C-Refl
  &\pathEq{\mathtt{x}}{\mathtt{x}} \land
  \pathEq{\mathtt{x.p}}{\mathtt{x.p}} \land
  \pathEq{\mathtt{y}}{\mathtt{y}} \land
  \pathEq{\mathtt{y.p}}{\mathtt{y.p}} && \text{(C-Refl)}\\
  % C-Class
  &\instBy{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Zero} && \text{(C-Class)}\\
  &\instBy{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Zero} && \text{(C-Class)}\\
  & ...  && \text{(C-Class)}\\
  % C-Subst
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \pathEq{\mathtt{y}}{\mathtt{y}} \rightarrow \pathEq{\mathtt{y}}{\mathtt{x}} && \text{(C-Subst)}\\
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \instOf{\mathtt{y}}{Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Subst)}\\
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \instBy{\mathtt{y}}{Nat} \rightarrow \instBy{\mathtt{x}}{\Nat} && \text{(C-Subst)}\\
  & ... && \text{(C-Subst)}\\
  % C-Prog
  &\instOf{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x}}{\Succ} \land \instOf{\mathtt{x.p}}{\Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Zero} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y.p}}{\Zero} \rightarrow \instOf{\mathtt{y.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Succ} \land \instOf{\mathtt{y.p}}{\Nat} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  % Many more
  &...\\
  % Entailment
  &\neg (\instBy{\mathtt{x}}{\Succ} \land
        \instBy{\mathtt{x.p}}{\Zero} \land
        \pathEq{\mathtt{x}}{\mathtt{y}} \rightarrow
          \instOf{y}{\Nat})
\end{align}

\subsection{Decidability}
\todo[inline]{%
  - decidability of the ground path depth encoding:\\
    - all declared datatypes have a finite domain\\
    - the encoding is quantifier free\\
    - hence, trivially decidable
}

\newpage
\subsection{Substitution in the Ground Encoding}
We want to finitely enumerate the quantified rule:
\begin{align*}
  % C-Subst: instOf
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land\\
  &\quad \instOf{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instOf{b}{c}
\end{align*}
The na\"ive approach would be to take the cross product of all quantified variables.
This would leave us with a lot of meaningless implications,
e.g. if we instantiate the rule with
$p=\mathtt{x}, v=\mathtt{y}, r=\mathtt{x}, a=\mathtt{y}, s=\mathtt{x}, b=\mathtt{x}, c=\Nat$
\begin{align*}
  % C-Subst: instOf
  &\pathEq{\mathtt{x}}{\mathtt{x}} \land {\color{red}\subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{y}}~\land
  \instOf{\mathtt{y}}{\Nat} \land \subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{x}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\Nat}
\end{align*}
Since we know the substitution to be false,
we do not have to include this instantiation into the encoding.
Since we only need to include rule instantiations where the substitution
predicate holds and we can calculate the substitution prior
since all quantified variables are known,
we can get rid of the substitution predicate in the encoding altogether.

E.g. the inatantiation with
$p=\mathtt{x}, v=\mathtt{x}, r=\mathtt{y}, a=\mathtt{y}, s=\mathtt{x}, b=\mathtt{x}, c=\Nat$
\begin{align*}
  % C-Subst: instOf
  &\pathEq{\mathtt{x}}{\mathtt{y}} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{y}}=\mathtt{y}}~\land
   \instOf{\mathtt{y}}{\Nat} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{x}}=\mathtt{x}}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\Nat}
\end{align*}
turns into
\[
  \pathEq{\mathtt{x}}{\mathtt{y}} \land \instOf{\mathtt{y}}{Nat} \rightarrow \instOf{\mathtt{x}}{\Nat}
\]

\section{Algorithmic Symmetry}
\label{sec:algo-symmetry}
We rely on the equivalency between the declarative and the algorithmic system
to set our depth limit for path enumeration
as well as on the decidability of the declarative system to even have such a limit in place.

The entailment $\entails{\pathEq{a}{b}}{\pathEq{b}{a}}$ is a counterexample
to \Cref{lem:2} (more precisely \Cref{lem:1})
and \Cref{thm:1} as it relies on \Cref{lem:2}.

\begin{lemma}[5.5.15]
  \label{lem:1}
  If \wf{P} and \entails{\ovl{a}}{a} then \entailsA{\ovl{a}}{a}.
\end{lemma}

\begin{lemma}[5.5.16]
  \label{lem:2}
  If \wf{P} then \entails{\ovl{a}}{a} iff \entailsA{\ovl{a}}{a}.
\end{lemma}

\begin{theorem}[5.5.1]
  \label{thm:1}
  If \wf{P} then derivation of \entails{\ovl{a}}{a} is decidable.
\end{theorem}

Counterexample for \Cref{lem:1}.
Choose any well-formed program.
\begin{prooftree}
  \AxiomC{}
  \RightLabel{C-Refl}
  \UnaryInfC{\entails{\cdot}{\pathEq{b}{b}}}
  \RightLabel{C-Weak}
  \UnaryInfC{\entails{\pathEq{a}{b}}{ \pathEq{b}{a}_{\sub{a}{b}} }}
  \AxiomC{}
  \RightLabel{C-Ident}
  \UnaryInfC{\entails{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \RightLabel{C-Subst}
  \BinaryInfC{\entails{\pathEq{a}{b}}{ \pathEq{b}{a}_{\sub{a}{a}} }}
\end{prooftree}

\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{a}}}
  \AxiomC{$a \sqsubset \pathEq{a}{b}$}
  \AxiomC{...}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
  \RightLabel{CA-Subst3}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{...}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
  \AxiomC{$b \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{b}}}
  \RightLabel{CA-Subst3}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\subsection{Symmetry Fix}
\label{sec:symmetry-fix}
We can update rule CA-Subst3 to allow the entailment used as a counterexample
to \Cref{lem:1} to have a derivation.

There are two feasible ways to update the rule:
\begin{enumerate}
  \item
  \begin{prooftree}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p}{p''}}}
    \AxiomC{$p \sqsubset \ovl{a}$}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p}{p'}}}
    \RightLabel{CA-Subst3Fix1}
    \TrinaryInfC{\entailsA{\ovl{a}}{\pathEq{p'}{p''}}}
  \end{prooftree}
  \item
  \begin{prooftree}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p''}{p}}}
    \AxiomC{$p \sqsubset \ovl{a}$}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p'}{p}}}
    \RightLabel{CA-Subst3Fix2}
    \TrinaryInfC{\entailsA{\ovl{a}}{\pathEq{p'}{p''}}}
  \end{prooftree}
\end{enumerate}

\subsubsection{Fix 1 derivation}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{a}}}
  \AxiomC{$a \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Ident}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \RightLabel{CA-Subst3Fix1}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\subsubsection{Fix 2 derivation}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Ident}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \AxiomC{$b \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{b}}}
  \RightLabel{CA-Subst3Fix2}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\subsubsection{Fix Implications}
\todo[inline]{%
  - Termination conserns\\
    - could just infinitely symmetric switch with CA-Subst3\\
    - need to limit it, s.t. path equivalencies might only be symmetrically switched once (using a "memory" context?)
}

\subsection{What to do with this?}
\begin{itemize}
  \item Update rule CA-Subst3 with one of the solutions from \Cref{sec:symmetry-fix}.
  \item Redo the proofs?
\end{itemize}

%\section{Runtime Comparison}
%add table

\end{document}
