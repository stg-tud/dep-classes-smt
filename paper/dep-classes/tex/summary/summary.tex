\documentclass[a4paper]{article}

%% packages
%%%%%%%%%%%
\usepackage[utf8x]{inputenc}
\usepackage[USenglish]{babel}
\usepackage{amsbsy,amscd,amsfonts,amssymb,amstext,amsmath,amsthm,latexsym}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{dot2texi}
\usepackage{url}
\usepackage{hyperref}
\usepackage[nottoc]{tocbibind}
\usepackage{pdfpages}

\usepackage{syntax}     % for bnf grammar
\usepackage{bussproofs} % for type rules
\usepackage{todonotes}

\usepackage{float}      % for figures
\floatstyle{boxed}
\restylefloat{figure}

\usepackage{listings}
\usepackage{xcolor}
%\usepackage{tikz}
%\usetikzlibrary{positioning,chains,shapes.arrows,shapes.geometric,fit,calc,arrows,decorations.pathmorphing}

%\usepackage{subfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{cleveref}   % for better references with \Cref
\usepackage{parskip}    % line breaks in texts

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\input{macros}
%\input{tikz}

\begin{document}

\section{Overview}
\section{DCC recap}
\subsection{Syntax}
\label{sec:syntax}
%\begin{figure}[h]
  \begin{align*}
    P &::= \ovl{D} && \text{(Program)}\\
    D &::= \constructorDeclaration{C}{x}{\ovl{a}}
      \mid \programEntailment{x}{\ovl{a}}{a}
      \mid \abstractMethodDeclaration{m}{x}{\ovl{a}}{t}
      \mid \methodImplementation{m}{x}{\ovl{a}}{t}{e} && \text{(Decl)}\\
    t &::= \type{x}{\ovl{a}} && \text{(Type)}\\
    a &::= \pathEq{p}{p}
      \mid \instOf{p}{C}
      \mid \instBy{p}{C} && \text{(Constr)}\\
    p &::= x \mid p.f && \text{(Path)}\\
    e &::= x
      \mid e.f
      \mid \objConstr{C}{\pathEq{\ovl{f}}{\ovl{e}}} && \text{(Expr)}
  \end{align*}
%\caption{DCC Syntax}
%\label{fig:syntax}
%\end{figure}

\subsection{Constraint Entailment}
\label{sec:constraint-entailment}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[C-Ident]{}{
      \entails{a}{a}
    }
    \and
    \inferrule[C-Refl]{}{
      \entails{\epsilon}{\pathEq{p}{p}}
    }
    \and
    \inferrule[C-Class]{
      \entails{\ovl{a}}{\instBy{p}{C}}
    }{
      \entails{\ovl{a}}{\instOf{p}{C}}
    }
    \and
    \inferrule[C-Cut]{
      \entails{\ovl{a}}{c}\\
      \entails{\ovl{a'},c}{b}
    }{
      \entails{\ovl{a},\ovl{a'}}{b}
    }
    \and
    \inferrule[C-Subst]{
      \entails{\ovl{a}}{a_{\sub{x}{p}}}\\
      \entails{\ovl{a}}{\pathEq{p'}{p}}
    }{
      \entails{\ovl{a}}{a_{\sub{x}{p'}}}
    }
    \and
    \inferrule[C-Prog]{
      (\programEntailment{x}{\ovl{a}}{a}) \in P\\
      \entails{\ovl{b}}{\ovl{a}_{\sub{x}{p}}}
    }{
      \entails{\ovl{a}}{a_{\sub{x}{p}}}
    }
  \end{mathpar}
%  \caption{Constraint Entailment}
%  \label{fig:constraint-entailment}
%\end{figure}

\subsection{Operational Semantics}
\label{sec:operational-semantics}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[R-New]{
      x \not \in \mathit{dom}(h)\\
      o = \stdobj\\\\
      \constructorDeclaration{C}{x}{\ovl{b}} \in P\\
      \entails{\mIt{HC}(h), \mIt{OC}(x, o)}{\ovl{b}}
    }{
      \pair{h}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}}} \rightarrow
        \pair{h, x \mapsto o}{x}
    }
    \and
    \inferrule[R-Field]{
      (\pathEq{x.f}{y}) \in \mIt{HC}(h)
    }{
      \pair{h}{x.f} \rightarrow
        \pair{h}{y}
    }
    \and
    \inferrule[R-Call]{
      S = \{ \pair{\ovl{a}}{e} | \pair{\ovl{a}}{e} \in \mIt{mImpl}(m, x) \land \entails{\mIt{HC}(h)}{\ovl{a}} \}\\
      \pair{\ovl{a}}{e} \in S\\
      \forall \pair{\ovl{a'}}{e'} \in S.~(e' \neq e) \longrightarrow \entails{\ovl{a'}}{\ovl{a}} \land \neg \entails{\ovl{a}}{\ovl{a'}}
    }{
      \pair{h}{m(x)} \rightarrow
        \pair{h}{e}
    }
    \and
    \inferrule[RC-Field]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{e.f} \rightarrow
        \pair{h'}{e'.f}
    }
    \and
    \inferrule[RC-Call]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{m(e)} \rightarrow
        \pair{h'}{m(e')}
    }
    \and
    \inferrule[RC-New]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}, \pathEq{f}{e}, \pathEq{\ovl{f'}}{\ovl{e'}}}} \rightarrow
        \pair{h'}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}, \pathEq{f}{e'}, \pathEq{\ovl{f'}}{\ovl{e'}}}}
    }
  \end{mathpar}
%  \caption{Operational Semantics}
%  \label{fig:operational-semantics}
%\end{figure}

\subsection{Type Assignment}
\label{sec:type-assignment}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[T-Field]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}\\
      \entails{\ovl{c}, \ovl{a}}{\instanceOf{x.f}{C}}\\\\
      \entails{\ovl{c}, \ovl{a}, \pathEq{x.f}{y}}{\ovl{b}}\\
      x \not \in \mIt{FV}(\ovl{b})
    }{
      \typeass{\ovl{c}}{e.f}{\type{y}{\ovl{b}}}
    }
    \and
    \inferrule[T-Call]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}\\
      \pair{\ovl{a'}}{\ovl{b}} \in \mIt{MType}(m, x, y)\\\\
      \entails{\ovl{c}, \ovl{a}}{\ovl{a'}}\\
      \entails{\ovl{c}, \ovl{a}, \ovl{b}}{\ovl{b'}}\\
      x \not \in \mIt{FV}(\ovl{b'})
    }{
      \typeass{\ovl{c}}{m(e)}{\type{y}{\ovl{b'}}}
    }
    \and
    \inferrule[T-Var]{
      \entails{\ovl{c}}{\instanceOf{x}{C}}
    }{
      \typeass{\ovl{c}}{x}{\type{y}{\pathEq{y}{x}}}
    }
    \and
    \inferrule[T-Sub]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a'}}}\\\\
      \entails{\ovl{c},\ovl{a'}}{\ovl{a}}
    }{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}
    }
    \and
    \inferrule[T-New]{
      \forall i.~\typeass{\ovl{c}}{e_i}{\type{x_i}{\ovl{a_i}}}\\\\
      \ovl{b} = (\instantiatedBy{x}{C}), \cup_{i} \ovl{a_i}_{\sub{x_i}{x.f_i}}\\\\
      \constructorDeclaration{C}{x}{\ovl{b'}} \in P\\
      \entails{\ovl{c}, \ovl{b}}{\ovl{b'}}
    }{
      \typeass{\ovl{c}}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{e}}}}{\type{x}{\ovl{b}}}
    }
  \end{mathpar}
%  \caption{Type Assignment}
%  \label{fig:type-assignment}
%\end{figure}

\subsection{Type Checking}
\label{sec:type-checking}
%\begin{figure}[h]
  \begin{mathpar}
    \inferrule[WF-CD]{
      \mIt{FV}(\ovl{a}) = \{ x \}
    }{
      \wf{\constructorDeclaration{C}{x}{\ovl{a}}}
    }
    \and
    \inferrule[WF-MS]{
      \mIt{FV}(\ovl{a}) = \{ x \}\\
      \mIt{FV}(\ovl{b}) = \{ x, y \}
    }{
      \wf{\abstractMethodDeclaration{m}{x}{\ovl{a}}{\type{y}{\ovl{b}}}}
    }
    \and
    \inferrule[WF-RD]{
      \mIt{FV}(\ovl{a}) = \{ x \}\\
      \instanceOf{x}{C'} \in \ovl{a}
    }{
      \wf{\programEntailment{x}{\ovl{a}}{\instanceOf{x}{C}}}
    }
    \and
    \inferrule[WF-MI]{
      \mIt{FV}(\ovl{a}) = \{ x \}\\
      \mIt{FV}(\ovl{b}) = \{ x, y \}\\
      \typeass{\ovl{a}}{e}{\type{y}{\ovl{b}}}
    }{
      \wf{\methodImplementation{m}{x}{\ovl{a}}{\type{y}{\ovl{b}}}{e}}
    }
    \and
    \inferrule[WF-Prog]{
      \forall D \in P.~\wf{D}\\
      \forall m.~\forall \pair{\ovl{a}}{\ovl{b}}, \pair{\ovl{a'}}{\ovl{b'}} \in \mIt{MType}(m, x, y).~\ovl{b}=\ovl{b'}\\
      \forall m.~\forall \pair{\ovl{a}}{\ovl{b}} \in \mIt{MType}(m, x, y).~\mathrm{complete}(m, \type{x}{\ovl{a}})\\
      \forall m. \mathrm{unique}(m)
    }{
      \wf{P}
    }
  \end{mathpar}
%  \caption{Type Checking}
%  \label{fig:type-checking}
%\end{figure}

\section{An Implementation}
% \todo[inline]{%
%   - interpreter for operational semantics\\
%   - type inference for type assignments for expressions\\
%   - type checking through inferring type and check subtype with annotated/expected type\\
%   - constraint entailment via SMT solving
% }

%One of our main goals is to provide an implementation for DCC. % TODO: what is/are the other/s? extend DCC?
We provide an implementation of
\begin{itemize}
  \item the constraint entailment,
  \item the operational semantics,
  \item the type assignment and
  \item the type checking excepting the completeness- and unique check for programs.
\end{itemize}

The implementation of the operational semantics is straightforward and resembles
the rules as seen in \Cref{sec:operational-semantics}.

The implementation of type assignment infers a suitable type for a given expression
(based on the rules of \Cref{sec:type-assignment}).
Checking if a given expression has a suspected type is done via
first inferring a type for the expression and then checking if the inferred type
is a subtype of the suspected type (rule T-Sub).

The implementation of type checking (well-formedness, \Cref{sec:type-checking}) is straightforward,
with the limitation that we skip the completeness- and unique check for programs.

Our approach for the implementation of the constraint entailment rules
from \Cref{sec:constraint-entailment} is to use a SMT solver to solve the constraint system,
s.t. for each entailment to solve we make a query to the solver.
This requires us to provide an encoding of the rules into (first-order) logic
to feed as input into the solver.

\section{Towards an SMT encoding}
% \todo[inline]{%
%   - idea (of master thesis): use smt solver\\
%   - first approach: resemble syntax based reasoning to stay close to \Cref{sec:constraint-entailment}\\
%     - unefficient (massive amount of ADTs and recursion needed, not what a SMT solver is good at)\\
%     - multiple infinite domains with ADTs\\
%   - second approach: use semantic reasoning, encode into FO with constraints being simple boolean predicates\\
%     - infinite datatypes are problematic, we will never be able to reject an entailment\\
%   - put solver limitations subsection here?\\
%   - third approach: get rid of the infinite structures\\
%     - limit path depth\\
%     - decidable encoding, we could just finitely enumerate all quantifiers\\
%   - 4th approach: ground encoding to see if it's more efficient\\
% }
Since we want to use a SMT solver for solving constraint entailments we need to
encode the calculus into (first-order) logic.
Creating this encoding is an iterative process for which we sketch the individual steps
we did.

Our first approach was to resemble the syntactic-reasoning of the sequent calculus (\ref{sec:constraint-entailment}) with the encoding.
For this we defined ADTs for the three constraint types as well as for paths and lists
and we used strings for representing variables, fields and classes.
This enabled us to encode the calculus rules in a highly computational form,
which made extensive use of recursive definitions ranging over the ADTs.
This performed badly. We were able to successfully show simple valid entailments,
but the solver gave up and returned \unknown~on more complex valid entailments.
Also the solver was not able to reject invalid entailments.

As it turned out, relying on the SMT solver to perform multiple recursive computations is problematic.
Hence we want to use a more semantics based approach of reasoning.
So instead of having lists of constraints which where instantiations of an ADT,
we want to employ simple boolean reasoning.
For this we transform the ADTs of the three constraint types into boolean predicates
and keep them unspecified. We also turn classes and fields and variables into enumeration types
as they are known from the context of the entailment to check and the program,
but we keep the ADT for paths as we still need it for computing substitutions.

\todo[inline]{small encoding example? (e.g. for one rule?)}

This improved the capability to accept valid entailments,
but the solver is still not able to reject invalid entailments.

% \paragraph{SMT Solver Limitations}
% Dealing with quantifiers and recursive definitions is hard for SMT solvers.
% Since SMT solvers do not use induction, proving any property that requires induction
% will fail if we want to use an off-the-shelf SMT solver.
% We might encounter a counterexample during unrolling of the recursive definitions,
% but if none exists we will get looping behaviour during e-matching.

\section{SMT solver limitations}
\label{sec:smt-limitations}
% \todo[inline]{%
%   - recursion + quantifiers + infinite (abstractt) datatypes bad\\
%   - implications of this (see stack overflow answer)\\
%     - the encoding won't be able to accept a query,
%       as it could just unroll the recusive definitions once more and might encounter a counterexample
%       (infinite domain)\\
%     - but it might find a solution to reject a query, as it might encounter a counterexample\\ 
%   - need to limit the use of them
% }
Dealing with quantifiers and recursive definitions is hard for SMT solvers.
Since SMT solvers do not use induction, proving any property that requires induction
will fail if we want to use an off-the-shelf SMT solver.
We might encounter a counterexample during unrolling of the recursive definitions,
but if none exists we will get looping behaviour during e-matching.

\section{Path Depth Limit Encoding}
% \todo[inline]{%
%   - avoid problems identified in SMT limitations\\
%   - need to get rid of the infinite domain of PATHS as well as avoid recursive computations in the solver\\
%   - idea: set a maximum path depth limit (the max amount of which a path might be expanded)\\
%     - e.g.: if the depth limit is set to 1, path x.f is within the limit while x.f.g is not.\\
%     - with the depth limit in place we can now enumerate all possible paths\\
%   - until now: we did rely on the solver to compute path substitutions\\
%   - this cannot be cleanly transformed with the path enumeration type\\
%     - also we want to avoid encoding recursive functions into the SMT solver\\
%   - the enumeration type however allows us to transform the computive substitution function into a predicate\\
%     - we can even compute all the cases in which this predicate will be true externally,
%       thus not relying on the solver for these computations anymore\\
%     - substitution function signature: $\Path \times \Variable \times \Path \times \Path$\\
%     - for $\mIt{substitute}(p,x,q,r)$ we write $\subst{p}{x}{q}=r$\\
%   - the quantifiers encoding the rules need to be updated to the new substitution style\\
%     - we need to check if the Substitution predicate holds in the lhs of the implications\\
%   %this is for a possibly later decidability section
%   - decidability of path depth encoding:\\
%     - all declared datatypes have a finite domain\\
%     - all quantifiers range over variables from the declared datatypes\\
%     - the encoding is decidable as we can finitely enumerate the quantifiers\\
%   - decidability of the ground path depth encoding:\\
%     - all declared datatypes have a finite domain\\
%     - the encoding is quantifier free\\
%     - hence, trivially decidable
% }

As mentioned in \Cref{sec:smt-limitations}, the use of recursive definitions in the encoding has
the effect that the SMT solver will in general not be able to find a solution.
The recusive definitions that remain in the encoding are the path datatype (infinite domain)
and the computation of substitutions.
The idea to get rid of these is to set a limit to the path depth,
meaning a restricting to witch point paths might be expanded.
E.g. if we set the depth limit to one the path $\mathtt{x.f}$ would be within the limit while
$\mathtt{x.f.g}$ would exceed the limit.
With a limit on the maximum path depth in place we can enumerate all possible paths
and transform the path datatype from an ADT to an enumeration type.

Until now we relied on the SMT solver to compute substitutions, but
the path enumeration type allows us to change how we deal with substitutions.
We can now transform the computive substitution function into a boolean predicate,
like we did with the constraints.
We define the predicate with the signature:
\[ \mIt{substitute}: \Path \times \Variable \times \Path \times \Path \]
For $\mIt{substitute}(p, x, q, r)$ we write $\subst{p}{x}{q}=r$,
giving us the notion that the predicate should be true if $r$ is the result
of the substitution of $x$ with $q$ in $p$.

Since all existing paths are now known prior to the solver,
we can compute each possible substitution externally and define the substitution predicate
to be true for exactly these inputs.

The quantified calculus rules need to be updated to respect the new substitution style,
e.g. we must check for correct substitutions in the premise of the rule.

\todo[inline]{example of comparison of previous (semantic) rule with new (depth limit) rule}

\subsection{Rule C-Prog}
% \todo[inline]{%
%   - C-Prog rule needs to be enumerated\\
%   - this is because the rule instantiates a declaration from the program\\
%   - this declaration introduces a variable and the rule would need to substitute this variable with a path\\
%   - since this variable introduced through the declaration
%     is not (neccecarily) part of the variables valid in the entailment context,
%     we cannot defer this substitution check to the SMT solver\\
%     - as this would require us to add the variable to be a possible variable for the entailment
%       and to be a valid path\\
%     - but it only is a intermediate variable used in the declaration and should not be present anywhere else\\
%   - so we need to compute the result of this substitution prior to the solver\\
%   - which is possible, since all valid paths are known a priory\\
%   - show C-Prog template
% }
With the path depth limit in place, we need to enumerate the C-Prog rule.
This is because the rule instantiates a declaration of the program
and this declaration introduces a variable that gets substituted in the rule.
We cannot defer the substitution check to the SMT solver (like we did in the other rules),
since the variable introduced by the declaration is only used as an intermediate value.
This variable should therefore not be present outside of this rule,
but having the substitution check in the solver would require exactly this.

This requires us to compute the substitution (think of it as intantiating the declaration with a concrete path)
prior to the solver, which is possible since all valid paths are known a priori.

\todo[inline]{C-Prog rule template}

\subsection{Example Encoding}
Assume the Natural Numbers program.
We want to encode
\[ \entails{\instBy{x}{\Succ}, \instBy{x.p}{\Zero}, \pathEq{x}{y}}{\instOf{y}{\Nat}} \]
using a depth limit of $1$.
\begin{align}
  &\texttt{\Variable} := \{\mathtt{x}, \mathtt{y}\}\\
  &\texttt{\Class} := \{\Zero,\Succ,\Nat\}\\
  &\texttt{\Path} := \{\mathtt{x}, \mathtt{x}.\mathtt{p}, \mathtt{y}, \mathtt{y}.\mathtt{p}\}\\
  % def subst
  &\subst{p}{v}{q} = s :=\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{x} \land s=\mathtt{x})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{x.p} \land s=\mathtt{x.p})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{y} \land s=\mathtt{y})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{y.p} \land s=\mathtt{y.p})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{x} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{x.p} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{y} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{y.p} \land s=\mathtt{x})~\lor\\
  &\quad (p=\mathtt{x.p} \land v=\mathtt{x} \land q=\mathtt{x} \land s=\mathtt{x.p})~\lor\\
  &\quad (p=\mathtt{x.p} \land v=\mathtt{x} \land q=\mathtt{y} \land s=\mathtt{y.p})~\lor\\
  &\quad~...\\
  % C-Refl
  &\forall p.~\pathEq{p}{p} && \text{(C-Refl)}\\
  % C-Class
  &\forall p, c.~\instBy{p}{c} \rightarrow \instOf{p}{c} && \text{(C-Class)}\\
  % C-Subst: pathEq
  &\forall p, q, v, r, s, a, b, c, d. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a \land \subst{q}{v}{r}=b~\land\\
  &\quad \pathEq{a}{b} \land
         \subst{p}{v}{s}=c \land \subst{q}{v}{s}=d\\
  &\qquad \rightarrow \pathEq{c}{d}\\
  % C-Subst: instOf
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land\\
  &\quad \instOf{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instOf{b}{c}\\
  % C-Subst: instBy
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land\\
  &\quad \instBy{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instBy{b}{c}\\
  % C-Prog
  &\instOf{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x}}{\Succ} \land \instOf{\mathtt{x.p}}{\Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Zero} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y.p}}{\Zero} \rightarrow \instOf{\mathtt{y.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Succ} \land \instOf{\mathtt{y.p}}{\Nat} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  % Entailment
  &\neg (\instBy{\mathtt{x}}{\Succ} \land \instBy{\mathtt{x.p}}{\Zero} \land \pathEq{\mathtt{x}}{\mathtt{y}} \rightarrow \instOf{\mathtt{y}}{\Nat})
\end{align}

\subsection{Decidability}
\label{sec:smt-depth-limit-decidability}
% \todo[inline]{%
%   - decidability of path depth encoding:\\
%     - all declared datatypes have a finite domain\\
%     - all quantifiers range over variables from the declared datatypes\\
%     - the encoding is decidable as we can finitely enumerate the quantifiers\\
% }
The encoding is decidable since we can finitely enumerate the quantifiers,
as all quantified variables range over a finite domain.
This is because all declared datatypes are enumeration types
with a finite amount of constructors and all quantified variables
range over one of the declared enumeration types.

\section{Grounding the Path Depth Limit Encoding}
% \todo[inline]{%
%   - goal: get a quantifier free encoding s.t. we can use one of the QF theories (and maybe even a different solver)\\
%   - approach: as discussed in the decidability section of the path depth limit encoding we can\\
%     - finitely enumerate the quantified variables\\
%   - put observations about substitution before the final encoding example\\
%   - with the observations about Substitution from the previous section
%     we can remove the substitution predicate from the encoding altogether\\
%   - also we only instantiate the quantifiers with interpretations that fulfill the substitution predicate\\
%   - this removes the complexity of the encoding,
%     as the solver doesnt have to check if the predicate holds for each individual assert
%     as well as reducing the overall number of assertions
% }
With the Path Depth Limit we have a (in theory) decidable encoding,
but we are still using quantifiers.
An idea is to ground the encoding.
This could result in a better solving performance, as quantifier instantiation
in the solver is expensive\todo{is this true in general? it's at least more expensive than not having to do it}
so using a quantifier free encoding might be beneficial.
It might also enable us to employ additional optimizations.

As discussed in \Cref{sec:smt-depth-limit-decidability} it is possible
to finitely enumerate all quantified variables.
So our first approach to ground the encoding is to do exactly this
and assert each single quantifier instantiation in a big conjunction.

\paragraph{Example}
\label{ex:smt-ground-instantiation}
Given the rule for substitutions over instance-of constraints (see \Cref{???}\todo{add rule as an example in prev section}),
we instantiate the rule for each combination of paths $p,r,s,a,b$,
variables $v$ and classes $c$ to obtain a ground formula.
Assume $p=r=s=b=\mathtt{x}$, $v=a=\mathtt{y}$ for some class $\mathtt{C}$,
we obtain the instantiation:
%
\begin{align*}
  &\pathEq{\mathtt{x}}{\mathtt{x}} \land \subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{y}~\land
  \instOf{\mathtt{y}}{\mathtt{C}} \land \subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{x}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\mathtt{C}}
\end{align*}

\subsection{Substitution in the Ground Encoding}
If we inspect the previous example,
we can make the following observations:
\begin{enumerate}
  \item Some of the substitution checks will be statically known to be false and
  \item all substitution checks can be statically decided.
\end{enumerate}

The previous example is an instantiation of the rule:
\begin{align*}
  % C-Subst: instOf
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land
         \instOf{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instOf{b}{c}
\end{align*}
The substitution check marked in red is statically/externally known to be false
and the one marked in blue is known to be true.
%
\begin{align*}
  % C-Subst: instOf
  &\pathEq{\mathtt{x}}{\mathtt{x}} \land {\color{red}\subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{y}}~\land
  \instOf{\mathtt{y}}{\mathtt{C}} \land {\color{blue}\subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{x}}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\mathtt{C}}
\end{align*}
%
From this we can conclude that this instantiation will never be used
in prvoing the property $\instanceOf{\mathtt{x}}{\mathtt{C}}$,
as the premise of the implication can never be fulfilled.

By inspecting another instantiation of the same rule,
e.g. with
$p=\mathtt{x}, v=\mathtt{x}, r=\mathtt{y}, a=\mathtt{y}, s=\mathtt{x}, b=\mathtt{x}, c=\mathtt{C}$
we obtain the formula:
\begin{align*}
  % C-Subst: instOf
  &\pathEq{\mathtt{x}}{\mathtt{y}} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{y}}=\mathtt{y}}~\land
   \instOf{\mathtt{y}}{\mathtt{C}} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{x}}=\mathtt{x}}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\mathtt{C}}
\end{align*}
In this instantiation both substitution checks are known to be true
and the rule might be usable in proving that $\instanceOf{\mathtt{x}}{\mathtt{C}}$.

With these observations we can modify the ground encoding as follows:
\begin{enumerate}
  \item We do not have to include formulae in the encoding that are not helping in showing a property.
        E.g. where the premise of an implication is known to be false.
  \item Since we can statically decide all substitution checks,
        we do not have to encode the substitution predicate.
        This is in synergy with the previous point,
        as removing the checks in the implications gets possible
        if we only add those formulae where the checks
        are guaranteed to be true.
\end{enumerate}

These changes reduce the complexity for the SMT solver as well as for the
generation of the query to be sent to the solver (preprocessing).
The SMT solver complexity is reduced through two steps.
(1) The removal of the substitution predicate removed the need for
the solver to check and
(2) the total amount of possibilities to check is lowered,
since the rules sent to the solver only include those cases where the
substitution check would have been true.

The reduction in complexity in the preprocessing is mainly due to the fact
that we do not have to generate the definition for the substitution predicate anymore,
which involved iterating over the cross product of the input parameters.

\paragraph{Example}
If we consider the two shown example instantiations, we would only take the second one
\begin{align*}
  % C-Subst: instOf
  &\pathEq{\mathtt{x}}{\mathtt{y}} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{y}}=\mathtt{y}}~\land
   \instOf{\mathtt{y}}{\mathtt{C}} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{x}}=\mathtt{x}}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\mathtt{C}}
\end{align*}
which with the mentioned modifications turns into the formula
\[
  \pathEq{\mathtt{x}}{\mathtt{y}} \land \instOf{\mathtt{y}}{\mathtt{C}} \rightarrow \instOf{\mathtt{x}}{\mathtt{C}}
\]

\subsection{Example Encoding}
Assume the program of Natural Numbers.
We want to encode
\[ \entails{\instBy{x}{\Succ}, \instBy{x.p}{\Zero}, \pathEq{x}{y}}{\instOf{y}{\Nat}} \]
using a path depth limit of $1$.
\setcounter{equation}{0}
% Alternatively for each align block
% \usepackage{etoolbox}
% \AtBeginEnvironment{align}{\setcounter{equation}{0}}
\begin{align}
  &\texttt{\Variable} := \{\mathtt{x}, \mathtt{y}\}\\
  &\texttt{\Class} := \{\Zero,\Succ,\Nat\}\\
  &\texttt{\Path} := \{\mathtt{x}, \mathtt{x.p}, \mathtt{y}, \mathtt{y.p}\}\\
  % C-Refl
  &\pathEq{\mathtt{x}}{\mathtt{x}} \land
  \pathEq{\mathtt{x.p}}{\mathtt{x.p}} \land
  \pathEq{\mathtt{y}}{\mathtt{y}} \land
  \pathEq{\mathtt{y.p}}{\mathtt{y.p}} && \text{(C-Refl)}\\
  % C-Class
  &\instBy{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Zero} && \text{(C-Class)}\\
  &\instBy{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Zero} && \text{(C-Class)}\\
  & ...  && \text{(C-Class)}\\
  % C-Subst
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \pathEq{\mathtt{y}}{\mathtt{y}} \rightarrow \pathEq{\mathtt{y}}{\mathtt{x}} && \text{(C-Subst)}\\
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \instOf{\mathtt{y}}{Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Subst)}\\
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \instBy{\mathtt{y}}{Nat} \rightarrow \instBy{\mathtt{x}}{\Nat} && \text{(C-Subst)}\\
  & ... && \text{(C-Subst)}\\
  % C-Prog
  &\instOf{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x}}{\Succ} \land \instOf{\mathtt{x.p}}{\Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Zero} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y.p}}{\Zero} \rightarrow \instOf{\mathtt{y.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Succ} \land \instOf{\mathtt{y.p}}{\Nat} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  % Many more
  &...\\
  % Entailment
  &\neg (\instBy{\mathtt{x}}{\Succ} \land
        \instBy{\mathtt{x.p}}{\Zero} \land
        \pathEq{\mathtt{x}}{\mathtt{y}} \rightarrow
          \instOf{y}{\Nat})
\end{align}

\subsection{Decidability}
% \todo[inline]{%
%   - decidability of the ground path depth encoding:\\
%     - all declared datatypes have a finite domain\\
%     - the encoding is quantifier free\\
%     - hence, trivially decidable
% }
The encoding is decidable,
as all declared datatypes have a finite domain
and the encoding is quantifier free.

\section{Determining a suitable depth limit}
\label{sec:determine-depth-limit}
% \todo[inline]{%
%   - how do we set the path depth limit s.t. we can find a solution to an entailment if one would exists\\
%   - refer to the algorithmic system\\
%   - and the equivalency between the algorithmic and the declarative system\\
%   - lemma in the algorithmic system defines set of variables that can occur in a proof\\
%   - show lemma/set construction?\\
%   - use this set to determine the max possible depth
% }
We have introduced an encoding that relies on a parameter
that limits the maximum path depth.
How do we set this limit and is it possible to set it such
that the solver finds a solution if one would exists in the sequent calculus.

\begin{lemma}[5.5.16]
  \label{lem:constraint-system-equiv}
  If \wf{P} then \entails{\ovl{a}}{a} iff \entailsA{\ovl{a}}{a}.
\end{lemma}

\begin{lemma}[5.5.1]
  \label{lem:algorithmic-system-decidable}
  \entailsA{\ovl{a}}{a} is decidable.
\end{lemma}

For this, we rely to the algorithmic system and the equivalency
between the algorithmic- and the declarative system (\Cref{lem:constraint-system-equiv})
and the decidability of the algorithmic system (\Cref{lem:algorithmic-system-decidable}).

The proof of \Cref{lem:algorithmic-system-decidable}
defines a set of paths $S''_{\ovl{a};a}$ and proves that
all judgements in the derivation contain only paths from this set.

We use this to set the depth limit parameter for the encoding
of the given entailment to solve.
For this we determine the path $p \in S''_{\ovl{a};a}$ s.t.
\[ \forall p' \in S''_{\ovl{a};a}.~\mIt{depth}(p) \geq \mIt{depth}(p') \]
and set the depth limit used for the encoding to be precisely $\mIt{depth}(p)$.

\section{Algorithmic Symmetry}
\label{sec:algo-symmetry}
As emphasized in \Cref{sec:determine-depth-limit}
we rely on the equivalency between the declarative and the algorithmic system
to set our depth limit for path enumeration
as well as on the decidability of the declarative system to even have such a limit in place.

\begin{lemma}[5.5.15]
  \label{lem:constraints-declarative-implies-algorithmic}
  If \wf{P} and \entails{\ovl{a}}{a} then \entailsA{\ovl{a}}{a}.
\end{lemma}

\begin{theorem}[5.5.1]
  \label{thm:declarative-system-decidable}
  If \wf{P} then derivation of \entails{\ovl{a}}{a} is decidable.
\end{theorem}

The entailment $\entails{\pathEq{a}{b}}{\pathEq{b}{a}}$ is a counterexample
to \Cref{lem:constraints-declarative-implies-algorithmic}
which describes one direction of \Cref{lem:constraint-system-equiv}
and \Cref{thm:declarative-system-decidable}
as it relies on \Cref{lem:constraint-system-equiv}.

\begin{mathpar}
  \inferrule[CA-Refl]{}{
    \entailsA{\ovl{a}}{\pathEq{p}{p}}
  }
  \and
  \inferrule[CA-Ident]{}{
    \entailsA{\ovl{a}}{a_i}
  }
  \and
  \inferrule[CA-Class]{
    \entailsA{\ovl{a}}{\instantiatedBy{p}{C}}
  }{
    \entailsA{\ovl{a}}{\instanceOf{p}{C}}
  }
  \and
  \inferrule[CA-Prog]{
    \entailsA{\ovl{a}}{\ovl{b}_{\sub{x}{p}}}\\
    p \sqsubset \ovl{a}\\\\
    (\programEntailment{x}{\ovl{b}}{\instanceOf{x}{C}}) \in P
  }{
    \entailsA{\ovl{a}}{\instanceOf{p}{C}}
  }
  \and
  \inferrule[CA-Subst1]{
    p \sqsubset \ovl{a}\\\\
    \entailsA{\ovl{a}}{\instantiatedBy{p}{C}}\\
    \entailsA{\ovl{a}}{\pathEq{p}{p'}}
  }{
    \entailsA{\ovl{a}}{\instantiatedBy{p'}{C}}
  }
  \and
  \inferrule[CA-Subst2]{
    p \sqsubset \ovl{a}\\\\
    \entailsA{\ovl{a}}{\instanceOf{p}{C}}\\
    \entailsA{\ovl{a}}{\pathEq{p}{p'}}
  }{
    \entailsA{\ovl{a}}{\instanceOf{p'}{C}}
  }
  \and
  \inferrule[CA-Subst3]{
    p \sqsubset \ovl{a}\\\\
    \entailsA{\ovl{a}}{\pathEq{p}{p''}}\\
    \entailsA{\ovl{a}}{\pathEq{p'}{p}}
  }{
    \entailsA{\ovl{a}}{\pathEq{p'}{p''}}
  }
  \and
  \inferrule[CA-Subst4]{
    \entailsA{\ovl{a}}{\pathEq{p}{p'}}
  }{
    \entailsA{\ovl{a}}{\pathEq{p.f}{p'.f}}
  }
\end{mathpar}

\paragraph{Counterexample}
Choose any well-formed program.

The entailment $\entails{\pathEq{a}{b}}{\pathEq{b}{a}}$ has
a derivation in the declarative system.
% how to typeset the rule names to the rhs?
% \begin{mathpar}
%   \inferrule[C-Subst]{
%     \inferrule[C-Weak]{
%       \inferrule[C-Refl]{}{\entails{\cdot}{\pathEq{b}{b}}}
%     }{
%       \entails{\pathEq{a}{b}}{\pathEq{b}{a}_{\sub{a}{b}}}
%     }\\
%     \inferrule[C-Ident]{}{\entails{\pathEq{a}{b}}{\pathEq{a}{b}}}
%   }{
%     \entails{\pathEq{a}{b}}{ \pathEq{b}{a}_{\sub{a}{a}} }
%   }
% \end{mathpar}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{C-Refl}
  \UnaryInfC{\entails{\cdot}{\pathEq{b}{b}}}
  \RightLabel{C-Weak}
  \UnaryInfC{\entails{\pathEq{a}{b}}{ \pathEq{b}{a}_{\sub{a}{b}} }}
  \AxiomC{}
  \RightLabel{C-Ident}
  \UnaryInfC{\entails{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \RightLabel{C-Subst}
  \BinaryInfC{\entails{\pathEq{a}{b}}{\pathEq{b}{a}_{\sub{a}{a}}}}
\end{prooftree}

In the algorithmic system, only rule CA-Subst3 applies.
We have two possible ways to approach this sequent.

\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{a}}}
  \AxiomC{$a \sqsubset \pathEq{a}{b}$}
  \AxiomC{...}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
  \RightLabel{CA-Subst3}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{...}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
  \AxiomC{$b \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{b}}}
  \RightLabel{CA-Subst3}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

We can see that we reproduce the same proof goal
in one of the branches of both possibilities
and we cannot close those branches.

\subsection{Symmetry Fix}
\label{sec:symmetry-fix}
We can update rule CA-Subst3 to allow the entailment used as a counterexample
to \Cref{lem:constraints-declarative-implies-algorithmic} to have a derivation.

There are two feasible ways to update the rule:
\begin{enumerate}
  \item
  \begin{prooftree}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p}{p''}}}
    \AxiomC{$p \sqsubset \ovl{a}$}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p}{p'}}}
    \RightLabel{CA-Subst3Fix1}
    \TrinaryInfC{\entailsA{\ovl{a}}{\pathEq{p'}{p''}}}
  \end{prooftree}
  \item
  \begin{prooftree}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p''}{p}}}
    \AxiomC{$p \sqsubset \ovl{a}$}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p'}{p}}}
    \RightLabel{CA-Subst3Fix2}
    \TrinaryInfC{\entailsA{\ovl{a}}{\pathEq{p'}{p''}}}
  \end{prooftree}
\end{enumerate}

\subsubsection{Fix 1 derivation}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{a}}}
  \AxiomC{$a \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Ident}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \RightLabel{CA-Subst3Fix1}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\subsubsection{Fix 2 derivation}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Ident}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \AxiomC{$b \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{b}}}
  \RightLabel{CA-Subst3Fix2}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\subsubsection{Fix Implications}
\todo[inline]{%
  - Termination concerns\\
    - could just infinitely symmetric switch with CA-Subst3\\
    - need to limit it, s.t. path equivalencies might only be symmetrically switched once (using a "memory" context?)\\
    - need some sort of memory anyways, even in the original version, as we could just choose the same path over and over again\\
      - need to memoize already tested paths per branch
}

\subsection{What to do with this?}
\begin{itemize}
  \item Update rule CA-Subst3 with one of the solutions from \Cref{sec:symmetry-fix}.
  \item Redo the proofs?
\end{itemize}

\section{Algorithmic System Implementation}
\wip

\section{Runtime Comparison}
%add table
\wip

\end{document}
