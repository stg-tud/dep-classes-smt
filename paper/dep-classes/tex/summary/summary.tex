\documentclass[a4paper]{article}

%% packages
%%%%%%%%%%%
\usepackage[utf8x]{inputenc}
\usepackage[USenglish]{babel}
\usepackage{amsbsy,amscd,amsfonts,amssymb,amstext,amsmath,amsthm,latexsym}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{dot2texi}
\usepackage{url}
\usepackage{hyperref}
\usepackage[nottoc]{tocbibind}
\usepackage{pdfpages}

\usepackage{syntax}     % for bnf grammar
\usepackage{bussproofs} % for type rules
\usepackage{todonotes}

\usepackage{float}      % for figures
\floatstyle{boxed}
\restylefloat{figure}

\usepackage{listings}
\usepackage{xcolor}
%\usepackage{tikz}
%\usetikzlibrary{positioning,chains,shapes.arrows,shapes.geometric,fit,calc,arrows,decorations.pathmorphing}

%\usepackage{subfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{cleveref}   % for better references with \Cref
\usepackage{parskip}    % line breaks in texts

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\input{macros}
%\input{tikz}

\begin{document}

\section{Overview}
\section{DCC recap}
%\subsection{Syntax}
\begin{figure}[h]
\begin{align*}
  P &::= \ovl{D} && \text{(Program)}\\
  D &::= \constructorDeclaration{C}{x}{\ovl{a}}
    \mid \programEntailment{x}{\ovl{a}}{a}
    \mid \abstractMethodDeclaration{m}{x}{\ovl{a}}{t}
    \mid \methodImplementation{m}{x}{\ovl{a}}{t}{e} && \text{(Decl)}\\
  t &::= \type{x}{\ovl{a}} && \text{(Type)}\\
  a &::= \pathEq{p}{p}
    \mid \instOf{p}{C}
    \mid \instBy{p}{C} && \text{(Constr)}\\
  p &::= x \mid p.f && \text{(Path)}\\
  e &::= x
    \mid e.f
    \mid \objConstr{C}{\pathEq{\ovl{f}}{\ovl{e}}} && \text{(Expr)}
\end{align*}
\caption{DCC Syntax}
\label{fig:syntax}
\end{figure}

%\subsection{Constraint Entailment}
\begin{figure}[h]
  \begin{mathpar}
    \inferrule[C-Ident]{}{
      \entails{a}{a}
    }
    \and
    \inferrule[C-Refl]{}{
      \entails{\epsilon}{\pathEq{p}{p}}
    }
    \and
    \inferrule[C-Class]{
      \entails{\ovl{a}}{\instBy{p}{C}}
    }{
      \entails{\ovl{a}}{\instOf{p}{C}}
    }
    \and
    \inferrule[C-Cut]{
      \entails{\ovl{a}}{c}\\
      \entails{\ovl{a'},c}{b}
    }{
      \entails{\ovl{a},\ovl{a'}}{b}
    }
    \and
    \inferrule[C-Subst]{
      \entails{\ovl{a}}{a_{\sub{x}{p}}}\\
      \entails{\ovl{a}}{\pathEq{p'}{p}}
    }{
      \entails{\ovl{a}}{a_{\sub{x}{p'}}}
    }
    \and
    \inferrule[C-Prog]{
      (\programEntailment{x}{\ovl{a}}{a}) \in P\\
      \entails{\ovl{b}}{\ovl{a}_{\sub{x}{p}}}
    }{
      \entails{\ovl{a}}{a_{\sub{x}{p}}}
    }
  \end{mathpar}
  \caption{Constraint Entailment}
  \label{fig:constraint-entailment}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
    \inferrule[R-New]{
      x \not \in \mathit{dom}(h)\\
      o = \stdobj\\\\
      \constructorDeclaration{C}{x}{\ovl{b}} \in P\\
      \entails{\mIt{HC}(h), \mIt{OC}(x, o)}{\ovl{b}}
    }{
      \pair{h}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}}} \rightarrow
        \pair{h, x \mapsto o}{x}
    }
    \and
    \inferrule[R-Field]{
      (\pathEq{x.f}{y}) \in \mIt{HC}(h)
    }{
      \pair{h}{x.f} \rightarrow
        \pair{h}{y}
    }
    \and
    \inferrule[R-Call]{
      S = \{ \pair{\ovl{a}}{e} | \pair{\ovl{a}}{e} \in \mIt{mImpl}(m, x) \land \entails{\mIt{HC}(h)}{\ovl{a}} \}\\
      \pair{\ovl{a}}{e} \in S\\
      \forall \pair{\ovl{a'}}{e'} \in S.~(e' \neq e) \longrightarrow \entails{\ovl{a'}}{\ovl{a}} \land \neg \entails{\ovl{a}}{\ovl{a'}}
    }{
      \pair{h}{m(x)} \rightarrow
        \pair{h}{e}
    }
    \and
    \inferrule[RC-Field]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{e.f} \rightarrow
        \pair{h'}{e'.f}
    }
    \and
    \inferrule[RC-Call]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{m(e)} \rightarrow
        \pair{h'}{m(e')}
    }
    \and
    \inferrule[RC-New]{
      \pair{h}{e} \rightarrow
        \pair{h'}{e'}
    }{
      \pair{h}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}, \pathEq{f}{e}, \pathEq{\ovl{f'}}{\ovl{e'}}}} \rightarrow
        \pair{h'}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{x}}, \pathEq{f}{e'}, \pathEq{\ovl{f'}}{\ovl{e'}}}}
    }
  \end{mathpar}
  \caption{Operational Semantics}
  \label{fig:operational-semantics}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
    \inferrule[T-Field]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}\\
      \entails{\ovl{c}, \ovl{a}}{\instanceOf{x.f}{C}}\\\\
      \entails{\ovl{c}, \ovl{a}, \pathEq{x.f}{y}}{\ovl{b}}\\
      x \not \in \mIt{FV}(\ovl{b})
    }{
      \typeass{\ovl{c}}{e.f}{\type{y}{\ovl{b}}}
    }
    \and
    \inferrule[T-Call]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}\\
      \pair{\ovl{a'}}{\ovl{b}} \in \mIt{MType}(m, x, y)\\\\
      \entails{\ovl{c}, \ovl{a}}{\ovl{a'}}\\
      \entails{\ovl{c}, \ovl{a}, \ovl{b}}{\ovl{b'}}\\
      x \not \in \mIt{FV}(\ovl{b'})
    }{
      \typeass{\ovl{c}}{m(e)}{\type{y}{\ovl{b'}}}
    }
    \and
    \inferrule[T-Var]{
      \entails{\ovl{c}}{\instanceOf{x}{C}}
    }{
      \typeass{\ovl{c}}{x}{\type{y}{\pathEq{y}{x}}}
    }
    \and
    \inferrule[T-Sub]{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a'}}}\\\\
      \entails{\ovl{c},\ovl{a'}}{\ovl{a}}
    }{
      \typeass{\ovl{c}}{e}{\type{x}{\ovl{a}}}
    }
    \and
    \inferrule[T-New]{
      \forall i.~\typeass{\ovl{c}}{e_i}{\type{x_i}{\ovl{a_i}}}\\\\
      \ovl{b} = (\instantiatedBy{x}{C}), \cup_{i} \ovl{a_i}_{\sub{x_i}{x.f_i}}\\\\
      \constructorDeclaration{C}{x}{\ovl{b'}} \in P\\
      \entails{\ovl{c}, \ovl{b}}{\ovl{b'}}
    }{
      \typeass{\ovl{c}}{\objConstr{C}{\pathEq{\ovl{f}}{\ovl{e}}}}{\type{x}{\ovl{b}}}
    }
  \end{mathpar}
  \caption{Type Assignment}
  \label{fig:type-assignment}
\end{figure}

\section{An Implementation}
\todo[inline]{%
  - interpreter for operational semantics\\
  - type inference for type assignments for expressions\\
  - type checking through inferring type and check subtype with annotated/expected type\\
  - constraint entailment via SMT solving
}

\section{Towards an SMT encoding}
\todo[inline]{%
  - idea (of master thesis): use smt solver\\
  - first approach: resemble syntax based reasoning to stay close to \Cref{fig:constraint-entailment}\\
    - unefficient (massive amount of ADTs and recursion needed, not what a SMT solver is good at)\\
  - second approach: use semantic reasoning, encode into FO with constraints being simple boolean predicates\\
    - infinite datatypes are problematic, we will never be able to reject an entailment\\
  - third approach: get rid of the infinite structures\\
    - limit path depth\\
    - decidable encoding, we could just finitely enumerate all quantifiers\\
  - 4th approach: ground encoding to see if it's more efficient\\
}

\section{SMT solver limitations}
\todo[inline]{%
  - recursion + quantifiers + infinite (abstractt) datatypes bad\\
  - need to limit the use of them
}

\section{Path Depth Limit Encoding}
To encode: $\entails{\instBy{x}{\Succ}, \instBy{x.p}{\Zero}, \pathEq{x}{y}}{\instOf{y}{\Nat}}$
with $\mathit{depth\!\!-\!\!limit}=1$
\begin{align}
  &\texttt{\Variable} := \{\mathtt{x}, \mathtt{y}\}\\
  &\texttt{\Class} := \{\Zero,\Succ,\Nat\}\\
  &\texttt{\Path} := \{\mathtt{x}, \mathtt{x}.\mathtt{p}, \mathtt{y}, \mathtt{y}.\mathtt{p}\}\\
  % def subst
  &\subst{p}{v}{q} = s :=\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{x} \land s=\mathtt{x})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{x.p} \land s=\mathtt{x.p})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{y} \land s=\mathtt{y})~\lor\\
  &\quad (p=\mathtt{x} \land v=\mathtt{x} \land q=\mathtt{y.p} \land s=\mathtt{y.p})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{x} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{x.p} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{y} \land s=\mathtt{x})~\lor\\
  %&\quad (p=\mathtt{x} \land v=\mathtt{y} \land q=\mathtt{y.p} \land s=\mathtt{x})~\lor\\
  &\quad (p=\mathtt{x.p} \land v=\mathtt{x} \land q=\mathtt{x} \land s=\mathtt{x.p})~\lor\\
  &\quad (p=\mathtt{x.p} \land v=\mathtt{x} \land q=\mathtt{y} \land s=\mathtt{y.p})~\lor\\
  &\quad~...\\
  % C-Refl
  &\forall p.~\pathEq{p}{p} && \text{(C-Refl)}\\
  % C-Class
  &\forall p, c.~\instBy{p}{c} \rightarrow \instOf{p}{c} && \text{(C-Class)}\\
  % C-Subst: pathEq
  &\forall p, q, v, r, s, a, b, c, d. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a \land \subst{q}{v}{r}=b~\land\\
  &\quad \pathEq{a}{b} \land
         \subst{p}{v}{s}=c \land \subst{q}{v}{s}=d\\
  &\qquad \rightarrow \pathEq{c}{d}\\
  % C-Subst: instOf
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land\\
  &\quad \instOf{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instOf{b}{c}\\
  % C-Subst: instBy
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land\\
  &\quad \instBy{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instBy{b}{c}\\
  % C-Prog
  &\instOf{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x}}{\Succ} \land \instOf{\mathtt{x.p}}{\Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Zero} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y.p}}{\Zero} \rightarrow \instOf{\mathtt{y.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Succ} \land \instOf{\mathtt{y.p}}{\Nat} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  % Entailment
  &\neg (\instBy{\mathtt{x}}{\Succ} \land \instBy{\mathtt{x.p}}{\Zero} \land \pathEq{\mathtt{x}}{\mathtt{y}} \rightarrow \instOf{\mathtt{y}}{\Nat})
\end{align}
\newpage

\section{Ground Encoding}
To encode: $\entails{\instBy{x}{\Succ}, \instBy{x.p}{\Zero}, \pathEq{x}{y}}{\instOf{y}{\Nat}}$
with $\mathit{depth\!\!-\!\!limit}=1$
\setcounter{equation}{0}
% Alternatively for each align block
% \usepackage{etoolbox}
% \AtBeginEnvironment{align}{\setcounter{equation}{0}}
\begin{align}
  &\texttt{\Variable} := \{\mathtt{x}, \mathtt{y}\}\\
  &\texttt{\Class} := \{\Zero,\Succ,\Nat\}\\
  &\texttt{\Path} := \{\mathtt{x}, \mathtt{x.p}, \mathtt{y}, \mathtt{y.p}\}\\
  % C-Refl
  &\pathEq{\mathtt{x}}{\mathtt{x}} \land
  \pathEq{\mathtt{x.p}}{\mathtt{x.p}} \land
  \pathEq{\mathtt{y}}{\mathtt{y}} \land
  \pathEq{\mathtt{y.p}}{\mathtt{y.p}} && \text{(C-Refl)}\\
  % C-Class
  &\instBy{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Zero} && \text{(C-Class)}\\
  &\instBy{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Zero} && \text{(C-Class)}\\
  & ...  && \text{(C-Class)}\\
  % C-Subst
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \pathEq{\mathtt{y}}{\mathtt{y}} \rightarrow \pathEq{\mathtt{y}}{\mathtt{x}} && \text{(C-Subst)}\\
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \instOf{\mathtt{y}}{Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Subst)}\\
  & \pathEq{\mathtt{x}}{\mathtt{y}} \land \instBy{\mathtt{y}}{Nat} \rightarrow \instBy{\mathtt{x}}{\Nat} && \text{(C-Subst)}\\
  & ... && \text{(C-Subst)}\\
  % C-Prog
  &\instOf{\mathtt{x}}{\Zero} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x.p}}{\Zero} \rightarrow \instOf{\mathtt{x.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{x}}{\Succ} \land \instOf{\mathtt{x.p}}{\Nat} \rightarrow \instOf{\mathtt{x}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Zero} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y.p}}{\Zero} \rightarrow \instOf{\mathtt{y.p}}{\Nat} && \text{(C-Prog)}\\
  &\instOf{\mathtt{y}}{\Succ} \land \instOf{\mathtt{y.p}}{\Nat} \rightarrow \instOf{\mathtt{y}}{\Nat} && \text{(C-Prog)}\\
  % Many more
  &...\\
  % Entailment
  &\neg (\instBy{\mathtt{x}}{\Succ} \land
        \instBy{\mathtt{x.p}}{\Zero} \land
        \pathEq{\mathtt{x}}{\mathtt{y}} \rightarrow
          \instOf{y}{\Nat})
\end{align}

\newpage
\subsection{Substitution in the Ground Encoding}
We want to finitely enumerate the quantified rule:
\begin{align*}
  % C-Subst: instOf
  &\forall p, c, v, r, s, a, b. && \text{(C-Subst)}\\
  &\quad \pathEq{s}{r} \land \subst{p}{v}{r}=a~\land\\
  &\quad \instOf{a}{c} \land
         \subst{p}{v}{s}=b\\
  &\qquad \rightarrow \instOf{b}{c}
\end{align*}
The na\"ive approach would be to take the cross product of all quantified variables.
This would leave us with a lot of meaningless implications,
e.g. if we instantiate the rule with
$p=\mathtt{x}, v=\mathtt{y}, r=\mathtt{x}, a=\mathtt{y}, s=\mathtt{x}, b=\mathtt{x}, c=\Nat$
\begin{align*}
  % C-Subst: instOf
  &\pathEq{\mathtt{x}}{\mathtt{x}} \land {\color{red}\subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{y}}~\land
  \instOf{\mathtt{y}}{\Nat} \land \subst{\mathtt{x}}{\mathtt{y}}{\mathtt{x}}=\mathtt{x}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\Nat}
\end{align*}
Since we know the substitution to be false,
we do not have to include this instantiation into the encoding.
Since we only need to include rule instantiations where the substitution
predicate holds and we can calculate the substitution prior
since all quantified variables are known,
we can get rid of the substitution predicate in the encoding altogether.

E.g. the inatantiation with
$p=\mathtt{x}, v=\mathtt{x}, r=\mathtt{y}, a=\mathtt{y}, s=\mathtt{x}, b=\mathtt{x}, c=\Nat$
\begin{align*}
  % C-Subst: instOf
  &\pathEq{\mathtt{x}}{\mathtt{y}} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{y}}=\mathtt{y}}~\land
   \instOf{\mathtt{y}}{\Nat} \land
   {\color{blue}\subst{\mathtt{x}}{\mathtt{x}}{\mathtt{x}}=\mathtt{x}}\\
  &\quad \rightarrow \instOf{\mathtt{x}}{\Nat}
\end{align*}
turns into
\[
  \pathEq{\mathtt{x}}{\mathtt{y}} \land \instOf{\mathtt{y}}{Nat} \rightarrow \instOf{\mathtt{x}}{\Nat}
\]

\section{Algorithmic Symmetry}
\label{sec:algo-symmetry}
We rely on the equivalency between the declarative and the algorithmic system
to set our depth limit for path enumeration
as well as on the decidability of the declarative system to even have such a limit in place.

The entailment $\entails{\pathEq{a}{b}}{\pathEq{b}{a}}$ is a counterexample
to \Cref{lem:2} (more precisely \Cref{lem:1})
and \Cref{thm:1} as it relies on \Cref{lem:2}.

\begin{lemma}[5.5.15]
  \label{lem:1}
  If \wf{P} and \entails{\ovl{a}}{a} then \entailsA{\ovl{a}}{a}.
\end{lemma}

\begin{lemma}[5.5.16]
  \label{lem:2}
  If \wf{P} then \entails{\ovl{a}}{a} iff \entailsA{\ovl{a}}{a}.
\end{lemma}

\begin{theorem}[5.5.1]
  \label{thm:1}
  If \wf{P} then derivation of \entails{\ovl{a}}{a} is decidable.
\end{theorem}

Counterexample for \Cref{lem:1}.
Choose any well-formed program.
\begin{prooftree}
  \AxiomC{}
  \RightLabel{C-Refl}
  \UnaryInfC{\entails{\cdot}{\pathEq{b}{b}}}
  \RightLabel{C-Weak}
  \UnaryInfC{\entails{\pathEq{a}{b}}{ \pathEq{b}{a}_{\sub{a}{b}} }}
  \AxiomC{}
  \RightLabel{C-Ident}
  \UnaryInfC{\entails{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \RightLabel{C-Subst}
  \BinaryInfC{\entails{\pathEq{a}{b}}{ \pathEq{b}{a}_{\sub{a}{a}} }}
\end{prooftree}

\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{a}}}
  \AxiomC{$a \sqsubset \pathEq{a}{b}$}
  \AxiomC{...}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
  \RightLabel{CA-Subst3}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\begin{prooftree}
  \AxiomC{...}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
  \AxiomC{$b \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{b}}}
  \RightLabel{CA-Subst3}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\subsection{Symmetry Fix}
\label{sec:symmetry-fix}
We can update rule CA-Subst3 to allow the entailment used as a counterexample
to \Cref{lem:1} to have a derivation.

There are two feasible ways to update the rule:
\begin{enumerate}
  \item
  \begin{prooftree}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p}{p''}}}
    \AxiomC{$p \sqsubset \ovl{a}$}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p}{p'}}}
    \RightLabel{CA-Subst3Fix1}
    \TrinaryInfC{\entailsA{\ovl{a}}{\pathEq{p'}{p''}}}
  \end{prooftree}
  \item
  \begin{prooftree}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p''}{p}}}
    \AxiomC{$p \sqsubset \ovl{a}$}
    \AxiomC{\entailsA{\ovl{a}}{\pathEq{p'}{p}}}
    \RightLabel{CA-Subst3Fix2}
    \TrinaryInfC{\entailsA{\ovl{a}}{\pathEq{p'}{p''}}}
  \end{prooftree}
\end{enumerate}

\subsubsection{Fix 1 derivation}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{a}}}
  \AxiomC{$a \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Ident}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \RightLabel{CA-Subst3Fix1}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\subsubsection{Fix 2 derivation}
\begin{prooftree}
  \AxiomC{}
  \RightLabel{CA-Ident}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{a}{b}}}
  \AxiomC{$b \sqsubset \pathEq{a}{b}$}
  \AxiomC{}
  \RightLabel{CA-Refl}
  \UnaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{b}}}
  \RightLabel{CA-Subst3Fix2}
  \TrinaryInfC{\entailsA{\pathEq{a}{b}}{\pathEq{b}{a}}}
\end{prooftree}

\subsubsection{Fix Implications}
\todo[inline]{%
  - Termination conserns\\
    - could just infinitely symmetric switch with CA-Subst3\\
    - need to limit it, s.t. path equivalencies might only be symmetrically switched once (using a "memory" context?)
}

\subsection{What to do with this?}
\begin{itemize}
  \item Update rule CA-Subst3 with one of the solutions from \Cref{sec:symmetry-fix}.
  \item Redo the proofs?
\end{itemize}

%\section{Runtime Comparison}
%add table

\end{document}
