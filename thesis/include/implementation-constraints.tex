\section{Constraint System}
The $DC_C$ constraint system as presented in \Cref{fig:dcc-constraint-entailment}
is specified in the style of the sequent calculus.
In order to use a SMT solver on the constraint system
we model the sequent calculus in sorted first-order logic.
The integration of the SMT solving with the Scala implementation
is done via calling the SMT solver as a sub-process and using
the SMT-Lib format for communicating information between
the Scala implementation and the solver process.
\\ \\
%- fo syntax description for special stuff
%  - pattern matching
%  - let bindings
%  - if statements (inline + multiline)
%  - sort (type) specifications
%  - parametrized list type
%  - pretty printing of sort constructors
In sorted first order logic variables are not limited to a single domain.
Variable bindings (e.g. in quantifiers)
have an assigned sort as seen in \Cref{fig:smtlib-example-fo},
where the all-quantified variable $x$ has the sort \mIt{List[Int]}.
The notion for such a sorted variable is $x: S$
for variables $x$ and sorts $S$.
% List functions
\begin{figure}[b]
\begin{align*}
&\mIt{elem}(c: \Constr, cs: \Constrs): Bool = cs \match\\
&\quad \case{\nil}{false}\\
&\quad \case{hd :: tl}{\ite{c = hd}{true}{\mIt{elem}(c, tl)}}\\\\
&\mIt{concat}(l_1: \Constrs, l_2: \Constrs): \Constrs = l_1 \match\\
&\quad \case{\nil}{l_2}\\
&\quad \case{hd :: tl}{hd :: \mIt{concat}(tl, l_2)}
\end{align*}
\caption{List functions}
\label{fig:fo-list-funs}
\end{figure}
%
We also use let-bindings, if statements, pattern matching and primitive recursive functions.
Let bindings are written with the keywords \Let and \textbf{in}.
If statements can be written inline as \ite{b}{x}{y} or using
the keywords \If, \Then and \textbf{else}.
Pattern matching is written using the notion $x \match$ to start matching some $x$
and patterns are specified using \case{y}{z},
where variables occurring in $y$ are bound in $z$.
Pattern matching can be written as a combination of if statements and let bindings
and is therefore used for better readability.

The parametrized sort \mIt{List} models lists and
is predefined in Z3.
The constructor \nil represents the empty list and
the constructor \mIt{insert} is used for list constructions
and \mIt{insert(x, l)} will also be written as $x :: l$
for elements $x$ and lists $l$ with matching sorts.
Selectors \mIt{head} and \mIt{tail} are used to extract
the head and tail from a list.
We write $[x_1, ..., x_n]$ as a shortcut for
$x_1 :: ... :: x_n :: \nil$ for lists with elements $\{x_i | i > 0 \land i \leq n\}$.
\Cref{fig:fo-list-funs} defines functions for list concatenation
as well as element-of checking.
We write $l_1 \conc l_2$ for concatenating two lists $l_1$ and $l_2$
and $x \in l$ for checking if element $x$ is in list $l$.

\subsection{Na\"ive approach}
%- naive approach
%- goal is to be as close to the calculus rules as possible
%- "preserve" structure of calculus rules
The goal of this model of the constraint system is to
be close to the given sequent calculus and to preserve
the structure of the calculus rules in the first-order formulae.\\
% Sorts
\begin{figure}[t]
\centering
\begin{subfigure}[c]{0.45\textwidth}
% BNF
\begin{align*}
\mIt{Path} &::=
     \mIt{String}\\
  &\quad|\ \mIt{Path.String}
\end{align*}
\end{subfigure}
\begin{subfigure}[c]{0.45\textwidth}
% BNF
\begin{align*}
\mIt{Constraint} &::=
     \pathEq{Path}{Path}\\
  &\quad|\ \instOf{Path}{String}\\
  &\quad|\ \instBy{Path}{String}
\end{align*}
\end{subfigure}
\caption{Sorts}
\label{subfig:axioms-naive-general-sorts}
\end{figure}\\
First we define a set of sorts, predicates and functions.
These definitions form the general structure of the model
and provide basic functionality needed in the modeling of the calculus rules.

Sorts for paths and constraints are defined in \Cref{subfig:axioms-naive-general-sorts}.
The definitions are similiar to the syntax specification in \Cref{fig:dcc-syntax}.
A path is either a variable name or a field path consiting
of another path followed by a field name, where variable and field names
are modeled as strings.
The three types of $DC_C$ constraints are translate as follows in our model:
\begin{itemize}
  \item For two paths $p, q$ the constraint \pathEq{p}{q} requires $p$ and $q$
        to be equivalent.
  \item For a path $p$ and a class name $C$ modeled as a string,
        \instOf{p}{C} requires path $p$ to be an instance of class $C$.
  \item For a path $p$ and a class name $C$ modeled as a string,
        \instBy{p}{C} requires path $p$ to be directly instantiated by class $C$.
\end{itemize}\quad
% Functions for substitution
\begin{figure}[t]
\centering
\begin{align*}
% path substitution
&\substpath{p_1: Path}{x: String}{p_2: Path}:\mIt{Path} = p_1 \match\\
&\quad y \Rightarrow \ite{x=y}{p_2}{p_1}\\
&\quad q.f \Rightarrow \substpath{q}{x}{p_2}.f\\
%&\quad \If \is{var}(p_1) \\
%&\qquad \Then x = \ite{id(p_1)}{p_2}{p_1}\\ % replace id(p_1)
%&\qquad \Else \substpath{obj(p_1)}{x}{p_2}.f\\ %: replace obj(p_1) and f
\\
% constraint substitution
&\substconstr{c: Constraint}{x: String}{p: Path}\mathit{: Constraint} = c \match \\
&\quad \case{\pathEq{q_1}{q_2}}
  {\pathEq
    {\substpath{q_1}{x}{p}}
    {\substpath{q_2}{x}{p}}}\\
&\quad \case{\instOf{q}{C}}
  {\instOf{\substpath{q}{x}{p}}{C}}\\
&\quad \case{\instBy{q}{C}}
  {\instBy{\substpath{q}{x}{p}}{C}}\\\\
% constraints substitution
&\substconstrs{cs: List[Constraint]}{x: String}{p: Path}\mathit{: List[Constraint]} =\\
&\quad cs \match\\
&\qquad \case{\epsilon}{\epsilon}\\
&\qquad \case{hd :: tl}
  {\substconstr{hd}{x}{p} ::
  \substconstrs{tl}{x}{p}}
\end{align*}
\caption{Path Substitution Functions}
\label{subfig:axioms-naive-general-funs}
\end{figure}\\
Functions defining path substitution are given in \Cref{subfig:axioms-naive-general-funs}.
Path substitution is the process of substituting the variable name of a path
with another path.
Therefore substitution can only occur on the innermost part of a path and
substitution only happens if the variable name of the path equals the variable name to be substituted.
Substitution for constraints propagates substitution to each path contained within a constraint.\\
E.g. for path equivalence constraints \pathEq{p_1}{p_2} a substitution from $x$ to $q$
substitutes both $p_1$ and $p_2$ with the substitution from $x$ to $q$.
Substitution for lists of constraints applies the substitution
to each constraint contained in the list.
Substitution for strings $x$ and paths $p$ will be written
for constraints $a$ as \subst{a}{x}{p} and
for constraint lists \ovl a as \subst{\ovl a}{x}{p},
function application is distinguishable based on the sort of the first argument.
% Predicates
\begin{figure}[h]
\centering
\begin{align*}
&\mathit{class}(\mathit{String}) \\
&\mathit{variable}(\mathit{String})\\
&\inprog(\mathit{String},\mathit{List[Constraint]}, \mathit{Constraint}) \\
&\mathit{entails}(\mathit{List[Constraint]}, \mathit{Constraint})\\\\
&\mathit{Entails(cs_1: List[Constraint], cs_2: List[Constraint])} = cs_2 \match\\
&\quad \case{\epsilon}{true}\\
&\quad \case{hd :: tl}{\mIt{entails}(cs_1, hd)} \land \mIt{Entails}(cs_1, tl)\\\\
&\mathit{subst(c_1: Constraint, x: String, p: Path, c_2: Constraint)} = \\
&\quad\substconstr{c_1}{x}{p} = c_2
\end{align*}
\caption{Predicates}
\label{subfig:axioms-naive-general-predicates}
\end{figure}\\
Predicates are declared in \Cref{subfig:axioms-naive-general-predicates}.
The predicate \mIt{class(C)} ensures that $C$ is a valid class name
and \mIt{variable(x)} ensures that $x$ is a valid variable name
of the program.
Class- and variable names are modeled as strings.
The predicate \inprog\ models the existence check of program entailments
as seen in rule C-Prog in \Cref{fig:dcc-constraint-entailment}.
For strings $x$, constraint lists \ovl{a} and constraints $a$,
$\inprog(x, \ovl{a}, a)$ ensures that a declaration \progEnt{x}{\ovl{a}}{a}
exists in the program.
The predicate \mIt{entails} models the entailment judgement of the sequent calculus.
The predicate \mIt{Entails} models the entailment judgement for multiple constraints,
which is defined as $\entails{\ovl a}{\ovl b} = \bigwedge_{b \in \ovl b}{\entails{\ovl a}{b}}$.
For constraint lists \ovl{a} and constraints $a$
$\mIt{entails}(\ovl{a}, a)$ ensures that \entails{\ovl{a}}{a} holds.
For constraint lists \ovl{a} and constraint lists \ovl{b},
$\mIt{Entails}(\ovl{a}, \ovl{b})$ holds if
$\mIt{entails}(\ovl{a}, b)$ holds for each $b \in \ovl{b}$.
For better readability in the rules, we write
%$\inprog(x, \ovl{a}, a)$ as $\progEnt{x}{\ovl{a}}{a} \in P$ and
$\mIt{entails}(\ovl{a}, a)$ as \entails{\ovl{a}}{a} and
$\mIt{Entails}(\ovl{a}, \ovl{b})$ as \entails{\ovl{a}}{\ovl{b}}.
The writing styles of \mIt{entails} and \mIt{Entails} can be distinguished
based on the sort of the right-hand side argument.
The predicate \mIt{subst} models constraint equality after substitution.
For constraints $a, b$, strings $x$, paths $p$
$\mIt{subst}(a, x, p, b)$ holds if
$x$ substituted with $p$ in $a$ equals $b$.
%- explain rules
%- list problems of these rules
%  - too complex (e.g. quantified variables, no direct way of deduction in subst rule)
%  - not "structured" (permutation)
%- pretty printing
%  - symbols for functions, etc
%  - substitution
%  - generalization
%  - list notion
%  - list concatenation + inserting
% figure naive axioms
\begin{figure}[h]
\begin{align*}
&\forall c: \Constr.\ \entails{[c]}{c} && \text{(C-Ident)} \\
&\forall p: \Path.\ \entails{\nil}{\pathEq{p}{p}} && \text{(C-Refl)} \\
&\forall \ovl{a}: \Constrs, p: \Path, C: \String.&& \text{(C-Class)} \\
&\quad \mIt{class}(C) \land \entails{\ovl{a}}{\instBy{p}{C}}
       \rightarrow \entails{\ovl{a}}{\instOf{p}{C}} \\
&\forall \ovl{a}, \ovl{a'}: \Constrs, b, c: \Constr. && \text{(C-Cut)} \\
&\quad \entails{\ovl a}{c} \land \entails{c :: \ovl{a'}}{b}
       \rightarrow \entails{\ovl a \conc \ovl{a'}}{b}\\
&\forall \ovl a: \Constrs, x: \String, p_1, p_2: \Path, a, a_1, a_2: \Constr. && \text{(C-Subst)} \\
&\quad \entails{\ovl a}{\pathEq{p_2}{p_1}} \land \mIt{variable}(x)
         \land \mIt{subst}(a, x, p_1, a_1) \land \mIt{subst}(a, x, p_2, a_2)\\
&\quad   \land \entails{\ovl a}{a_1}
       \rightarrow \entails{\ovl a}{a_2} \\
&\forall \ovl a, \ovl b: \Constrs, a: \Constr, x: \String, p: \Path. && \text{(C-Prog)} \\
&\quad \inprog(x, \ovl a, a) \land \entails{\ovl b}{\subst{\ovl a}{x}{p}}
       \rightarrow \entails{\ovl b}{\subst{a}{x}{p}} \\
&\forall \ovl a: \Constrs, a, b: \Constr. && \text{(C-Weak)} \\
&\quad \entails{\ovl a}{b}
       \rightarrow \entails{a :: \ovl a}{b}\\
&\forall \ovl a, \ovl b: \Constrs, a: \Constr. && \text{(C-Perm)} \\
&\quad \forall b: \Constr.\ 
           b \in \ovl a \rightarrow b \in \ovl b
           \land
           \neg b \in \ovl a \rightarrow \neg b \in \ovl b\\
&\quad \land \entails{\ovl a}{a}
       \rightarrow \entails{\ovl b}{a}
\end{align*}
\caption{First-order Model Of Constraint Entailment}
\label{fig:axioms-naive}
\end{figure}\\
With the previous sort, predicate and function definitions
we can model the calculus rules.
A first-order representation of the calculus rules is given in \Cref{fig:axioms-naive}

We start with the structural rules for weakening, contraction and permutation
of the sequent calculus that are implicitly assumed in the $DC_C$ constraint system.
Since the entailment judgement of the $DC_C$ constraint system
has only a single constraint on its right-hand side
we only need to consider structural rules on the left-hand side.

Weakening allows the addition of arbitrary elements to a sequence.
The weakening rule in the $DC_C$ sequent calculus would look as follows:
\begin{prooftree}
\RightLabel{C-Weak}
\AxiomC{\entails{\ovl a}{b}}
\UnaryInfC{\entails{a, \ovl a}{b}}
\end{prooftree}
The rule states that it is always possible to restrict the context of an entailment.
The first-order representation of this rule models this as follows:
For constraint lists \ovl a and constraints $a, b$,
if \entails{\ovl a}{b} holds then \entails{a :: \ovl a}{b} holds as well.
Here we restrict the context \ovl a by prepending an additional constraint $a$.

Contraction and permutation assure that the ordering of a sequent
and the existence of multiple occurences of the same element in a sequent
do not matter. Rule C-Perm covers both cases.
For constraint lists \ovl a, \ovl b and constraints $a$:
if \entails{\ovl a}{a} holds then \entails{\ovl b}{a} holds as well
if both lists \ovl a and \ovl b consist of the same elements.
This is checked with an additional quantifier ranging over constraints $b$.
If $b$ is an element of \ovl a then it must also be an element of \ovl b
and if $b$ is not in \ovl a then it must not be in \ovl b.
This ensures that the ordering of the context does not matter
and since we do not require the length of \ovl a and \ovl b to be equal
it does also allow for the removal of multiple occurences of the same element
as long as one remains.
\\\\
The modeling of the remaining rules follow the structure of the rules
specified in the $DC_C$ constraint system in \Cref{fig:dcc-constraint-entailment}.

Rules C-Ident and C-Refl are closure rules.
Rule C-Ident states that each constraint entails itself.
For all constraints $c$, $c$ is entailed by a context consisting
of the identical constraint $[c]$.
Rule C-Refl states that path equivalence is reflexive,
each path is equivalent to itself without any prerequisites.
For all constraints $p$, \pathEq{p}{p} is entailed by the empty context \nil.

Rule C-Class establishes the fact that an object created with
a constructor of a class is an instance of that class.
For all constraints \ovl a, paths $p$ and strings $C$:
\instOf{p}{c} is entailed by context \ovl a if
\instBy{p}{C} is entailed by context \ovl a.
We make sure that $C$ is a classname by requiring that \mIt{class(C)} holds.

Rule C-Cut is a standard rule of the sequent calculus.
It states that if a constraint $c$ is entailed by a context \ovl a
and a constraint $b$ is entailed by a context \ovl b containing $c$
then $b$ is also entailed by \ovl a and \ovl b without $c$,
meaning that we can replace $c$ in \ovl b with constraints \ovl a
entailing $c$.
In our model we use the list structure of our context to
make this replacement.
In the model the context of $b$ is a list $\ovl b = c :: \ovl{a'}$
and the context of $c$ is \ovl a.
We then concatenate \ovl a with \ovl{a'}, which is the remainder
of $b$ without $c$ to eliminate $c$ from the context of $b$.

Rule C-Subst establishes that equivalent paths can be substituted
within constraints.
A constraint $a_2$ is entailed by \ovl a if
a constraint $a_1$ is entailed by \ovl a
and \ovl a entails the equivalence of paths $p_2$ and $p_1$.
For this $a_2$ needs to be equal to the substitution of $a$ from $x$ to $p_2$
and $a_1$ needs to be equal to the substitution of $a$ from $x$ to $p_1$.
\mIt{variable(x)} ensures that $x$ is a valid variable name.

Rule C-Prog applies program entailments expressing inheritance to the calculus.
For constraint lists \ovl a, \ovl b, constraints $a$, strings $x$ and paths $p$:
if a program entailment \progEnt{x}{\ovl a}{a} exists in the program
and \ovl a is entailed by \ovl b then $a$ is entailed by \ovl b as well.
$x$ is eliminated in \ovl a and $a$ through substitution,
since $x$ is the bound variable name of the program entailment.
The existence check of the program entailment is modeled with the predicate
$\inprog(x, \ovl a, a)$.

\begin{example}[Constraint entailment]
\label{ex:application-entailment}
In this example we will show the application of the sequent calculus for constraint entailment
and compare it to the application of our model of the calculus.
We will show the resolution of the entailment \entails{\pathEq{x}{y}}{\pathEq{y}{x}}
stating the symmetry of path equivalence.\\
\\
We begin with the application of the sequent calculus:
\begin{prooftree}
\AxiomC{}
\RightLabel{C-Refl}
\UnaryInfC{\entails{\epsilon}{\pathEq{y}{y}}}
\RightLabel{C-Weak}
\UnaryInfC{\entails{\pathEq{x}{y}}{\pathEq{y}{y}}}
\UnaryInfC{\entails{\pathEq{x}{y}}{\subst{\pathEq{y}{x}}{x}{y}}}
\AxiomC{}
\RightLabel{C-Ident}
\UnaryInfC{\entails{\pathEq{x}{y}}{\pathEq{x}{y}}}
\RightLabel{C-Subst}
\BinaryInfC{\entails{\pathEq{x}{y}}{\subst{\pathEq{y}{x}}{x}{x}}}
\end{prooftree}
For showing that \entails{\pathEq{x}{y}}{\pathEq{y}{x}} holds we
apply rule C-Subst.
We choose \pathEq{x}{y} to be our equivalent paths used for substitution.
To show that \pathEq{x}{y} is entailed by \pathEq{x}{y} we use rule C-Ident
to close this branch.
What is left to show is that \pathEq{x}{y} entails \subst{\pathEq{y}{x}}{x}{y}.
We apply the substitution to gain the constraint \pathEq{y}{y}.
Finally we apply rule C-Weak to remove the information \pathEq{x}{y} from the context
and apply rule C-Refl to show the entailment \entails{\epsilon}{\pathEq{y}{y}}
and close the branch.
With this derivation we showed \entails{\pathEq{x}{y}}{\subst{\pathEq{y}{x}}{x}{x}}.
We apply the substitution to obtain our original goal \entails{\pathEq{x}{y}}{\pathEq{y}{x}}.\\
\\
We now try to find a solution for the same entailment in our model.
The entailment has two valid variable names $x$ and $y$ which we need to add in our model.
We do so by requiring \mIt{variable(\str x)} and \mIt{variable(\str y)}.
Since there are no valid classnames we do not have to add any requirements for the \mIt{class} predicate.

To show \entails{\pathEq{x}{y}}{\pathEq{y}{x}} we instantiate rule C-Subst.
Since we want to show the entailment we need it to appear on the right-hand side of the implication,
for this we instantiate \ovl a as $[\pathEq{x}{y}]$ and $a_2$ as \pathEq{y}{x}.
We then choose $x := \str x$, $p_1 := y$ amd $p_2 := x$ for usage in the substitutions.
The instantiation of $x$ with $\str x$ ensures that \mIt{variable(x)} holds.
With the instantiations of $x$, $p_1$, $p_2$ and $a_2$ we get
\mIt{subst(a, \str x, y, a_1)} and \mIt{subst(a, \str x, x, \pathEq{y}{x})}.
We now need to choose $a$ and $a_2$ such that both \mIt{subst} requirements are fulfilled.
We instantiate $a := \pathEq{y}{x}$ and can resolve \mIt{subst(\pathEq{y}{x}, \str x, x, \pathEq{y}{x})}
requiring $\subst{\pathEq{y}{x}}{\str x}{x} = \pathEq{y}{x}$.
Applying the substitution shows that \pathEq{y}{x} is equal to \pathEq{y}{x}.
From \mIt{subst(\pathEq{y}{x}, \str x, y, a_1)} we know that
$a_1$ needs to be equal to $\subst{\pathEq{y}{x}}{\str x}{y} = \pathEq{y}{y}$
and we choose $a_1 := \pathEq{y}{y}$.
This leaves us with two new subgoals:
\begin{enumerate}
    \item \entails{[\pathEq{x}{y}]}{\pathEq{x}{y}} and
    \item \entails{[\pathEq{x}{y}]}{\pathEq{y}{y}}.
\end{enumerate}
To show (1) we instantiate rule C-Ident with $c := \pathEq{x}{y}$.\\
To show (2) we instantiate rule C-Weak with
$a := \pathEq{x}{y}$ and $\ovl a := \nil$ to match the context
and $b := \pathEq{y}{y}$ to match the constraint to be entailed by this context.
This leads to the new subgoal \entails{\nil}{\pathEq{y}{y}} which can be
resolved using rule C-Refl and instantiating $p := y$.\\
\\
By comparing the application of the sequent calculus with the application of our model,
we can see that both derivations are similiar.
Both derivations use the same rule applications in the same order to obtain the result
that the entailment holds.
We can also observe that we chose the variable instantiations of rule C-Subst
in the application of our model to match the path equivalence and substitution used
in the application of the sequent calculus.
\end{example}

\subsection{Rule Refinement}
In \Cref{ex:application-entailment} we have seen the application of our model
of the constraint entailment. The structure of the derivation followed the application
of the sequent calculus.
In the example we used rule C-Subst and chose the quantified variables
to fulfill the various requirements of the rule.
These requirements included \mIt{variable} and \mIt{subst} as well
as the relationship between variables $a$, $a_1$ and $a_2$.
We found that making these variable instantiations is diffucult for the solver
and we refine the modeled rules for better usage with the solver.

\subsubsection{Rule C-Subst}
We start with refining rule C-Subst.
The identified problems of this rule are
\begin{enumerate}
    \item the amount of quantified variables and
    \item the non-algorithmic nature of the rule.
\end{enumerate}
\quad\\
As observed in (1) the rule quantifies over seven variables.
This leads to the explosion of the search space for this rule
and the quantifier instantiation routines of the solver have a
problem to instantiate the quantified variables in a fitting way.
To solve this problem we try to ground at least some
of the quantified variables of the rule.
We notice that all variable names and paths are known at runtime
and none of the rules introduces new ones.
We can ground variables $x$, $p_1$ and $p_2$ of rule C-Subst
by enumerating each possible combination of those variables
and by creating a specialized subst rule for each of these combinations.

Following this we can transform the rule C-Subst given in \Cref{fig:axioms-naive}
by removing the quantified variables $x$, $p_1$ and $p_2$
and since we enumerate over each variable name
we do also remove the \mIt{variable(x)} requirement.
With this we reduced the number of quantified variables
of the rule to four.
We note that these variables are now free in the rule
and would need to be supplied from the outside.
Since we do not want a single rule with free variables,
but rather a template for generating subst rules,
we treat the now free variables as placeholders for
a routine that replaces these for each possible combination.
For better visibility we write the placeholders in bold: % TODO: upper case bold?
\begin{align*}
&\forall \ovl a: \Constrs, a, a_1, a_2: \Constr. && \text{(C-Subst)} \\
&\quad \entails{\ovl a}{\pathEq{\mathbf{p_2}}{\mathbf{p_1}}}
         \land \mIt{subst}(a, \mathbf{x}, \mathbf{p_1}, a_1) \land \mIt{subst}(a, \mathbf{x}, \mathbf{p_2}, a_2)
       \land \entails{\ovl a}{a_1}\\
&\quad \rightarrow \entails{\ovl a}{a_2}
\end{align*}
%
For (2) we take a look the instantiations of $a$, $a_1$ and $a_2$
made in \Cref{ex:application-entailment}.
In the example we started with instantiating $a_2$ to match
the entailment to be shown.
Afterwards we chose $a$ such that the substitution of
$x$ with $p_2$ in $a$ would equal $a_2$.
We see that to instantiate $a$ we solved a substitution
where $a$ is used as the input and $a_2$ as the output of the substitution.
Finally we instantiated $a_1$ with $x$ substituted with $p_1$ in $a$.
We observe that this resembles a linear instantiation scheme starting with $a_2$,
but we note that we had to make an educated guess for choosing $a$.
So with the current rule, the solver needs to make random instantiations
for $a$ to afterwards check if the requirements on $a$ are met
instead of following the observed instantiation pattern we did manually.
To resolve this problem we need to change the rule that $a$ can be
instantiated by direct derivating from $a_2$.
As previously stated we used $a$ on a input position
and $a_2$ on the output position of a function call.
To reverse these positions, we introduce \mIt{generalization} as
the inverse of substitution.
% Functions for generalization
\begin{figure}[t]
\centering
\begin{align*}
% path generalization
&\genp(p_1: Path, p_2: Path, x: String):\mIt{Path} = \\
&\quad\If p_1 = p_2\\
&\qquad \Then x\\
&\qquad \Else p_1 \match\\
&\qquad\quad y \Rightarrow y\\
&\qquad\quad q.f \Rightarrow \genp(q, p_2, x).f\\
%\ite{(p_1 = p_2)}{x}{
%p_1 \match\\
%&\qquad y \Rightarrow y\\
%&\qquad q.f \Rightarrow \genp(q, p_2, x).f
%}\\
\\
% constraint generalization
&\genc(c: \Constr, p: Path, x: String): \Constr = c \match\\
&\quad \case{\pathEq{q_1}{q_2}}
  {\pathEq
    {\genp(q_1, p, x)}
    {\genp(q_2, p, x)}}\\
&\quad \case{\instOf{q}{C}}
  {\instOf{\genp(q, p, x)}{C}}\\
&\quad \case{\instBy{q}{C}}
  {\instBy{\genp(q, p, x)}{C}}\\\\
\end{align*}
\caption{Path Generalization Functions}
\label{fig:axioms-general-gen}
\end{figure}\\
Functions for generalizing paths and constraints are defined in \Cref{fig:axioms-general-gen}.
Generalization for paths functions reverse of substitution for paths.
Instead of substituting a variable with a path we generalize a subpath with a variable.
This generalization of a subpath cannot happen at random places inside a path,
but only starting on the innermost/leftmost variable of the path (the root of the path AST).
For example we can generalize $x.f$ with $y$ in $x.f.g$ to obtain $y.g$,
but we cannot generalize $f.g$ with $h$ in $x.f.g$
since $f$ is not the innermost occurence in $x.f.g$.
So we can only start generalization from the variable of a path and not its fields.
For paths $p, q$ and strings $x$ path generalization is defined
such that $gen(subst(p, x, q), q, x) = p$.\\
Generalization for constraints does,
as substitution for constraints did,
propagate path generalization to the paths contained in the constraint
to be generalized.

For the notation of generalization we use \gen{c}{p}{x} for
generalizing paths $p$ with variable names $x$ in constraints $c$.
This notion is similiar to the one used for substitution.
We can distinguish both notations based on the swapped positions
of $p$ and $x$.
%
\begin{figure}[h]
\begin{align*}
&\forall \ovl a: \Constrs, a_2: \Constr. && \text{(C-Subst)}\\
&\quad \Let a := \gen{a_2}{\mathbf{p_2}}{\mathbf{x}}\ \In\\%\genc(a_2, \mathbf{p_2}, \mathbf{x})\ \In\\
&\qquad \Let a_1 := \subst{a}{\mathbf{x}}{\mathbf{p_1}}\\ %\substc(a, \mathbf{x}, \mathbf{p_1})\\
&\qquad \In
        \entails{\ovl a}{\pathEq{\mathbf{p_2}}{\mathbf{p_1}}}
        \land
        \entails{\ovl a}{a_1}\\
&\rightarrow \entails{\ovl a}{a_2}
\end{align*}
\caption{C-Subst Template}
\label{fig:axioms-csubst}
\end{figure}\\
We can now solve the problem of choosing an instantiation for $a$.
With the concept of generalization as previously presented
we can choose $a$ to be a generalization of $a_2$,
where $a_2$ is used in an input position
and the output is used as the instantiation of $a$.
This brings the instantiations of $a$, $a_1$ and $a_2$
into a derivation chain starting from
$a_2$ over $a$ to $a_1$.
Since we can derive $a$ and $a_1$ from $a_2$ through a defined function,
we can remove $a$ and $a_1$ from the list of quantified variables.\\
\\
We incorporate these changes into the template presented in step (1)
to obtain the new template for rule C-Subst as shown in \Cref{fig:axioms-csubst}.
In this template we reduced the amount of quantified variables to two.
These two quantified variables can be used to match the right-hand side
of the implication.
We used let bindings to derive $a$ from $a_2$ and $a_1$ from $a$.\\
\\
We can combine the observations made in steps (1) and (2)
to improve the rule generation out of the template.
A procedure to generate subst rules out of the template
needs to enumerate over all possible combinations of
variable names and path pairs.

The first observation to make is that in order to be complete
we do not need all possible combinations.
We can safely remove combinations where $x = p_1 = p_2$ for strings $x$ and paths $p_1, p_2$,
since there is no new information to be gained out of such a combination.
For $a$ we derive $\gen{a_2}{p_2}{x}$
and since $p_2 = x$ we obtain $a := a_2$.
The following derivation would then be $\subst{a}{x}{p_1}$
and since $x = p_1$ and $a = a_2$ we obtain $a_1 := a_2$.
This results in the implication:
\[ \entails{\ovl a}{\pathEq{p_2}{p_1}} \land \entails{\ovl a}{a_1} \rightarrow \entails{\ovl a}{a_2} \]
Since $p_1 = p_2$ and path equivalence is reflexive
\entails{\ovl a}{\pathEq{p_2}{p_1}} holds for any \ovl a
and since $a_2 = a = a_1$ we remain with
\[ \entails{\ovl a}{a_2} \rightarrow \entails{\ovl a}{a_2} \]
from where we can not gain any information.
More so this could lead for the solver to repetitively try to use this rule
and loop.\\
\\
The second observation follows from the first.
We can omit
\begin{enumerate}
    \item the generalization \gen{a_2}{p_2}{x} if $x = p_2$,
          since $\gen{a_2}{x}{x} = a_2$.
    \item the substitution \subst{a}{x}{p_1} if $x = p_1$,
          since $\subst{a}{x}{x} = a$.
    \item the entailment check \entails{\ovl a}{\pathEq{p_2}{p_1}} if $p_1 = p_2$,
          since \entails{\ovl a}{\pathEq{p}{p}} is derivable through using rule C-Weak
          until we obtain \entails{\nil}{\pathEq{p}{p}} followed
          by using rule C-Refl to close the proof.
\end{enumerate}
By omitting the generalization or the substitution
we can remove the respective let binding
and replace the now free variable in its subexpression.
\Cref{ex:subst-optimzed} shows this for the case $x = p_1$.
\begin{example}[Optimzed subst rule with $x = p_1$]
\label{ex:subst-optimzed}
\begin{align*}
&\forall \ovl a: \Constrs, a_2: \Constr.\\
&\quad \Let a := \gen{a_2}{\mathbf{p_2}}{\mathbf{x}}\\
&\quad \In
       \entails{\ovl a}{\pathEq{\mathbf{p_2}}{\mathbf{p_1}}}
       \land
       \entails{\ovl a}{a}\\
&\rightarrow \entails{\ovl a}{a_2}
\end{align*}
\end{example}
%
\subsubsection{Rule C-Prog}
\label{sec:cprog}
Rule C-Prog has similiar problems as the ones observed for rule C-Subst.
The rule is again defined in a non-algorithmic way.\\
The check if a program entailment exists in the program is done via
the predicate \inprog(x, \ovl a, a) for strings $x$, constraint lists \ovl a and constraints $a$,
where $x$ denotes a variable binding that can occur in \ovl a and $a$.
The predicate models the existence of a declaration
\progEnt{x}{\ovl a}{a} in the program.
This is aggravated by the fact that the rule requires us
to find a substitution from $x$ to some path $p$ to eliminate
the bound variable of the program entailment $x$,
since it would be otherwise free in the constraint entailment.\\
\\
To solve this problem we apply the same technique as
we previously did with rule C-Subst.\\
We can enumerate over all possible combinations of variable names and paths
to eliminate the need to find a proper substitution.
As well as finding a way to express the existence check
of program entailments in a derivable way,
where the quantified constraint $a$ can be used as an input
and would result in an output to be usable as an instantiation for $\ovl a$.

With this requirement specification we see that we want to have
some sort of lookup function ranging from constraint $a$ to constraints $\ovl a$.
Such a lookup function would need to be specifically generated for a program
and we cannot give a universal function definition.

We develop the generation process of a lookup function which models
the existence check from rule C-Prog through a series of examples.
Since such a lookup function needs to be specific to a given program,
we start by defining a set of program entailments in \Cref{ex:progent-inheritance}.
%
\begin{example}[Program entailment class hierarchy]\quad\\
\label{ex:progent-inheritance}
The program for which we want to generate a lookup function
contains the following entailment declarations.
\begin{align*}
&\progEnt{x}{\instOf{x}{B}}{\instOf{x}{A}}\\
&\progEnt{x}{\instOf{x}{C}, \instOf{x.f}{D}}{\instOf{x}{A}}\\
&\progEnt{x}{\instOf{x}{E}}{\instOf{x}{D}}
\end{align*}
Since program entailments are used to express inheritance relations,
the given entailments form the following class hierarchy.
\begin{center}
\begin{tikzpicture}
  \node (A) at (-1,0) {A};
  \node (B) at (-3,-1.5) {B};
  \node (C) at (1,-1.5) {C};
  \path (A) edge (B);
  \path (A) edge (C);
  
  \node (D) at (3,0) {D};
  \node (E) at (3,-1.5) {E};
  \path (D) edge (E);
% \node (comment) at (-0.5, -0.5) {asdf};
\end{tikzpicture}
\end{center}
\end{example}\quad\\
We recall from \Cref{fig:dcc-wf} that a program entailment \progEnt{y}{\ovl b}{b}
is only well formed if constraint $b$ is
of the form \instOf{q}{Cls} and $\instOf{q}{Cls'} \in \ovl b$.\\
With this in mind, rule C-Prog states that to show that
path $q$ is an instance of class $Cls$ it suffices to show
that $q$ is an instance of subclass $Cls'$
and that the field requirements of $Cls'$ are fulfilled.

To traslate this into a lookup function,
we use $b$ as an argument to the function and \ovl b as our return value.
Since a function needs to be total we need to combine all
existing program entailments into one function,
as well as the need for a result in the case where no match exists.

Since the well formedness requires \ovl b to contain at least
one element \ovl b cannot be empty and we use the
empty list $\nil$ as the return value for the non matching case.\\
To differentiate between program entailments we use if statements
to check if the input matches one of the program entailments.\\
Such a lookup function is shown in \Cref{ex:lookup-fun-ite}.

\begin{example}[Lookup function using if statements]
\label{ex:lookup-fun-ite}
\begin{align*}
&\mIt{lookup}(a: \Constr): \Constrs = \\
&\If a = \instOf{x}{A}\\
&\Then [\instOf{x}{B}]\\
&\Else \If a = \instOf{x}{A}\\
&\quad \Then [\instOf{x}{C}, \instOf{x.f}{D}]\\
&\quad \Else\If a = \instOf{x}{D}\\
&\qquad \Then [[\instOf{x}{E}]]\\
&\qquad \Else \nil\\
\end{align*}
\end{example}
%
We can observe in \Cref{ex:lookup-fun-ite} that we
created one if statement per program entailment.
This practice can lead to the shadowing of program entailments
as seen in the example, where the first and the second if statement share the same guard.
This is the case because there can be more than one entailment
with the same right-hand side constraint,
as seen in the given program entailments in \Cref{ex:progent-inheritance}.
This leads to shadowing, since we use the
right-hand side as the guard for the if statements.\\
\\
To avoid this shadowing of entailments,
we need to change the return type of the lookup function
from returning a list of constraints (\Constrs)
to returning a list of a list of constraints (\Constrss).\\
This enables us to merge program entailments that
share the same right-hand side together.
With this we can give the function definition shown in
\Cref{ex:lookup-fun-shadowing} that avoids shadowing.
%
\begin{example}[Avoid shadowing in lookup]
\label{ex:lookup-fun-shadowing}
\begin{align*}
&\mIt{lookup}(a: \Constr): \Constrss = \\
&\If a = \instOf{x}{A}\\
&\Then [[\instOf{x}{B}], [\instOf{x}{C}, \instOf{x.f}{D}]]\\
&\Else \If a = \instOf{x}{D}\\
&\quad\Then [[\instOf{x}{E}]]\\
&\quad\Else \nil\\
\end{align*}
\end{example}
%
We can see in \Cref{ex:lookup-fun-shadowing}
that we merged the two entailments whose right-hand side
is $\instOf{x}{A}$ and return both possible constraint lists
as the result for a match to these entailments.

To translate program entailments \progEnt{y}{\ovl b}{b}
we used $b$ to check for equality to the argument to the function
and \ovl b as the return value.
As of now we neglected the bound variable $y$ of the program entailment.\\
So we only solved the non-algorithmic nature of the rule
and we still need to find a suitable substitution
of the quantified variable $a$ from rule C-Prog
to input into the lookup function, such that the substitution of $a$ matches $b$.
We can incorporate the enumeration of combinations of variable names and paths
into the lookup function generation to resolve this.\\
\\
To do this we look at rule C-Prog and
see that the bound variable of the program entailment is used
for the substitution.
This is because, according to the well formedness,
for program entailments \progEnt{y}{\ovl b}{b}
only the bound variable $y$ can occur in \ovl b
and $b$ needs to be of the form \instOf{y}{Cls}
for some class name \mIt{Cls}.
So for finding a valid substitution,
we can fix the variable name to be substituted to $y$.\\
Since we fixed the variable name to be substituted,
what remains is the need to instantiate each program entailment
with each possible path.
Previously we only needed to generate a lookup function per program.
Now we need to generate a new lookup function
for each constraint entailment we want to show,
since we enumerate over all possible paths.

With this in mind we generate a lookup function for the
program entailments shown in \Cref{ex:progent-inheritance}
with valid paths $y$ and $y.g$.
The resulting lookup function is shown in \Cref{ex:lookup-fun}.
\newpage
\begin{example}[Program entailment lookup function]\quad\\
\label{ex:lookup-fun}
\begin{align*}
&\mIt{lookup}(a: \Constr): \Constrss = \\
&\If a = \instOf{y}{A}\\
&\Then [[\instOf{y}{B}], [\instOf{y}{C}, \instOf{y.f}{D}]]\\
&\Else \If a = \instOf{y}{D}\\
&\quad \Then [[\instOf{y}{E}]]\\
&\quad \Else \If a = \instOf{y.g}{A}\\
&\qquad \Then [[\instOf{y.g}{B}], [\instOf{y.g}{C}, \instOf{y.g.f}{D}]]\\
&\qquad \Else \If a = \instOf{y.g}{D} \\
&\qquad\quad \Then [[\instOf{y.g}{E}]]\\
&\qquad\quad \Else \nil
\end{align*}
\end{example}
If we compare \Cref{ex:lookup-fun-shadowing} and \Cref{ex:lookup-fun},
we can observe that the function in \Cref{ex:lookup-fun} uses
twice as much if statements as the function in \Cref{ex:lookup-fun-shadowing}.
This is because we instantiated each of the entailments with two possible paths,
doubling the amount of cases to consider.\\
\\
With the final lookup function definition from \Cref{ex:lookup-fun}
we can refine rule \mbox{C-Prog}.
We do this by replacing the declarative requirement of the $\inprog$ predicate
with the algorithmic call to the lookup function.
%
\begin{figure}[h]
\begin{align*}
&\forall \ovl a: \Constrs, a: \Constr. && \text{(C-Prog)}\\
&\Let \ovl{\ovl a} := lookup(a)\\   %\bar{\bar a}
&\In
     \neg (\ovl{\ovl a} = \nil)
   \land
     \bigvee_{\ovl b \in \ovl{\ovl a}}{\entails{\ovl a}{\ovl b}}
   \rightarrow \entails{\ovl a}{a}
\end{align*}
\caption{Rule C-Prog Using Lookup}
\label{fig:axioms-cprog}
\end{figure}\\\\
%
The refined rule C-Prog is defined in \Cref{fig:axioms-cprog}.\\
The rule calls function \mIt{lookup} to check
if a entailment declaration matching $a$ exists in the program.
The result is a list containing possible constraint lists
to evaluate for entailment to $a$.\\
Since we modeled the lookup function to return the empty list $\nil$
if no matching entailment declaration exists,
we require the lookup result \ovl{\ovl a} to be non empty.\\
Since we merged entailment declarations with matching right-hand sides
to avoid shadowing, it suffices to show that at least one
of the constraits lists contained in \ovl{\ovl a}
is entailed by \ovl a to show that $a$ is entailed by \ovl{a}.\\
\\
The refined rule C-Prog does not contain any free variables
and is therefore not a template like the refined C-Subst,
but a general rule that does not need any preprocessing.
This is the case because we moved the enumeration process
of possible paths into the generation of the lookup function.

\subsubsection{Rule C-Perm}
The permutation rule C-Perm is defined in a
non-structural way.
The SMT solver can use the rule without a problem to check for
two known entailments \entails{\ovl a}{a} and \entails{\ovl b}{a}
if \ovl a is a permutation of \ovl b.
The solver struggels with using this rule
for generating new entailments \entails{\ovl b}{a}
from a single known entailment \entails{\ovl a}{a},
such that \ovl b is a permutation of \ovl a.\\
\\
The permutation generating aspect is, in our model,
used for closures with rule C-Ident in combination with rule C-Weak
since our model is list based.
Rule C-Ident requires a list containing only one
element for its context and rule C-Weak can only
eliminate the first element from the context.
Therefore to close a proof for \entails{\ovl c}{c} with C-Ident
where $c \in \ovl c$ and $\neg (last(\ovl c) = c)$,
we need to find a permutation \ovl{c'} of \ovl c
where $last(\ovl{c'}) = c$.
%
\begin{figure}[h]
\begin{align*}
&\forall \ovl c: \Constrs, c: \Constr. && \text{C-DirectIdent}\\
&\quad c \in \ovl c \rightarrow \entails{\ovl c}{c}
\end{align*}
\caption{Rule C-DirectIdent}
\label{fig:axioms-cdirectident}
\end{figure}\\
%
To avoid the generation of permutations by the solver,
we define a rule for direct closure for such entailments
using rule C-Ident.\\
We introduce rule C-DirectIdent in \Cref{fig:axioms-cdirectident}.
Rule C-DirectIdent can be used to directly close entailments
of the form \entails{\ovl c}{c} if $c \in \ovl c$.\\
Rule C-DirectIdent introduces a new quantified variable,
potentially leading to an increased search space for the solver.
This is not the case for the rule.
The newly introduced quantified variable \ovl c
is contained in the entailment we want to show
and therefore used in an input position
which can be easily matched by the solver.
This is also true for the the quantified variable $c$
in combination with the element of check.
Both quantified variables are used in input positions.
Therefore the solver does not need to generate
instantiations that match the property $c \in \ovl c$,
but can rather check if the property is fulfilled
for the known values.\\
\\
Rule C-DirectIdent does not contradict any of the other rules.
It can solely be used as a "shortcut" for rule C-Ident.
We show that rule C-DirectIdent and rule C-Ident are interchangeable.\\
\\
Each entailment \entails{\ovl c}{c} closable with rule C-DirectIdent
can also be closed with the usage of rule C-Ident.
We produce a derivation for \entails{\ovl c}{c}
without the usage of C-DirectIdent.
Since the entailment is closable by C-DirectIdent,
we know that $c \in \ovl c$.
We generate a permutation \ovl{c'} of \ovl c
with the property $last(\ovl{c'}) = c$.
We do this by appending $c$ at the end of \ovl c
and obtain $\ovl{c'} := \ovl c \conc [c]$.
\ovl{c'} is a valid permutation in our model,
since rule C-Perm does not require
both lists to be of equal length and
we know that $c \in \ovl c$.
From there we repeatedly apply rule C-Weak
until we are left with the subgoal \entails{[c]}{c}.
We show this entailment by applying rule C-Ident.\\
\\
Each entailment \entails{\ovl c}{c} closable with rule C-Ident
can also be closed with the usage of rule C-DirectIdent.
The entailment is closable with rule C-Ident,
we therefore know that \ovl c is of the form $[c]$.
Since $c \in [c]$, we show the entailment \entails{[c]}{c}
by directly applying rule C-Ident.\\
\\
We showed that each entailment closable by C-DirectIdent
can also be closed by C-Ident and vice versa.
We replace rule C-Ident with rule C-DirectIdent.

\subsection{Scala Integration}
To integrate the model of the sequent calculus
into the Scala implementation, we need to translate the
first-order model into the SMT-Lib format.
We also need a procedure for preprocessing,
since we enumerated over variable names and paths
in the refined rules C-Subst and C-Prog.
Entailments can then be checked by calling the SMT solver
with the translated and preprocessed model
and the entailment to check.

\subsubsection{SMTLib Representation}
First we give a SMTLib representation for
the sort, predicate and functions definitions
and the non-preprocessed rules.\\
\\
We translate the sorts defined in \Cref{subfig:axioms-naive-general-predicates}.
The parametrized list datatype used is predefined in Z3.
We define sorts \mIt{CList} and \mIt{CsList},
to increase compatibility with other solvers
and to avoid ambiguities with the usage of \Constrs and \Constrss
We write \Constrs for \mIt{CList}
and \Constrss for \mIt{CsList}.
The SMTLib representation is defined in \Cref{fig:smtlib-sorts}.
All datatypes are defined with unique constructor- and selector names.
%
\begin{figure}[h]
\begin{lstlisting}[language=smtlib]
(declare-datatype Path (
  (var (id String))
  (pth (obj Path) (field String))))
(declare-datatype Constraint (
  (path-eq (p-left Path) (p-right Path))
  (instance-of (instance Path) (cls String))
  (instantiated-by (object Path) (clsname String))))
(declare-datatype CList (
  (empty)
  (construct (first Constraint) (rest CList))))
(declare-datatype CsList (
  (nan)
  (cons (hd CList) (tl CsList))))
\end{lstlisting}
\caption{SMTLib Datatype Declarations}
\label{fig:smtlib-sorts}
\end{figure}\\
%
\Cref{fig:smtlib-funs-list} shows a SMTLib translation
of the list functions defined in \Cref{fig:fo-list-funs}.\\
We can define recursive functions in the SMTLib format
with the keyword \lstinline[language=smtlib]{define-fun-rec}.
The functions in the first-order model used pattern matching
for better readability. While SMTLib supports pattern matching,
it is not fully supported by the latest version of Z3.
We translated the pattern matching using if statements,
where the guard checks for specific constructors of a datatype.\\
This can be observed in the translation of the list concatenating \mIt{conc}.
We used an if statement to check wheter the first argument $l1$
is a list construction with \mIt{\is{construct}(l1)}.
These constructor checking functions get automatically
generated for each constructor of a datatype declaration.
Since the \mIt{CList} datatype has only two constructors,
the else part of the if statement must match the empty list
and we do not need to further check for its constrcutor.

We avoided the introduction of new local variable bindings
through let where the new binding would be used only once.
We directly applied the selectors for those occurences.
%
\begin{figure}[t]
\begin{lstlisting}[language=smtlib]
(define-fun-rec conc ((l1 CList) (l2 CList)) CList
  (ite (is-construct l1)
    (construct (first l1) (conc (rest l1) l2))
     l2))
(define-fun-rec elem ((c Constraint) (cs CList)) Bool
  (ite (is-construct cs)
    (ite (= c (first cs))
       true
      (elem c (rest cs)))
     false))
\end{lstlisting}
\caption{SMTLib List Functions}
\label{fig:smtlib-funs-list}
\end{figure}\\
%
\begin{figure}[h]
\begin{lstlisting}[language=smtlib]
(define-fun-rec generalize-path
  ((p1 Path) (p2 Path) (x String)) Path
  (ite (= p1 p2)
    (var x)
    (ite (is-var p1)
       p1
      (pth (generalize-path (obj p1) p2 x)
           (field p1)))))
(define-fun generalize-constraint
  ((c Constraint) (p Path) (x String)) Constraint
  (ite (is-path-eq c)
    (path-eq (generalize-path (p-left c) p x)
             (generalize-path (p-right c) p x))
    (ite (is-instance-of c)
      (instance-of (generalize-path (instance c) p x) (cls c))
      (instantiated-by (generalize-path (object c) p x)
                       (clsname c)))))
\end{lstlisting}
\caption{SMTLib Representation of Generalization}
\label{fig:smtlib-funs-gen}
\end{figure}\\
%
\begin{figure}[t]
\begin{lstlisting}[language=smtlib]
(define-fun-rec subst-path
  ((p1 Path) (x String) (p2 Path)) Path
  (ite (is-var p1)
    (ite (= x (id p1))
      p2
      p1)
    (pth (subst-path (obj p1) x p2) (field p1))))
(define-fun subst-constraint
  ((c Constraint) (x String) (p Path)) Constraint
  (ite (is-path-eq c)
    (path-eq (subst-path (p-left c) x p)
             (subst-path (p-right c) x p))
    (ite (is-instance-of c)
      (instance-of (subst-path (instance c) x p) (cls c))
      (instantiated-by (subst-path (object c) x p) (clsname c)
     ))))
(define-fun-rec subst-constraints
  ((cs CList) (x String) (p Path)) CList
  (ite (is-construct cs)
    (construct (subst-constraint
                 (first cs) x p)
                 (subst-constraints (rest cs) x p))
     empty))
\end{lstlisting}
\caption{SMTLib Representation of Substitution}
\label{fig:smtlib-funs-subst}
\end{figure}
A SMTLib translation for substitution defined in \Cref{subfig:axioms-naive-general-funs}
is given in \Cref{fig:smtlib-funs-subst}
and the SMTLib representation for generalization
defined in \Cref{fig:axioms-general-gen} can be found in \Cref{fig:smtlib-funs-gen}.\\
The translations for substitution and generalization
follow the same pattern regarding pattern matching
as the translation of the list functions shown previously.
We define non-recursive functions using the keywords \smtlib{define-fun},
so we strictly distinguish syntactically between recursive
and non-recursive functions in the SMTLib format.
%
\begin{figure}[h]
\begin{lstlisting}[language=smtlib]
// Base Properties
(declare-fun class (String) Bool)
// DCC Properties
(declare-fun entails (CList Constraint) Bool)
(define-fun-rec Entails ((cs1 CList) (cs2 CList)) Bool
  (ite (is-construct cs2)
    (and (entails cs1 (first cs2))
         (Entails cs1 (rest cs2)))
     true))
\end{lstlisting}
\caption{SMTLib Predicate Definitions}
\label{fig:smtlib-predicates}
\end{figure}\\
A SMTLib representation of the predicates defined in \Cref{subfig:axioms-naive-general-predicates}
is given in \Cref{fig:smtlib-predicates}.
We can declare undefined functions with the keywords \smtlib{declare-fun}.
Those function declarations are specified,
like the predicates in the first-order model,
through requiring that specific instances of the function hold.
\\
We kept only the predicate \mIt{class}, since the refined rules
C-Subst and C-Prog enumerate over valid variable names and paths,
and the entailment predicates. %\mIt{entails} and \mIt{Entails}.
%The predicate \mIt{Entails} is defined as a recusive function. % TODO: readd these? (removed because too long and ugly in pdf)
\\
%
\begin{figure}[t]
\begin{lstlisting}[language=smtlib]
(assert (!
  (forall ((p Path)) (entails empty (path-eq p p)))
  :named C-Refl))
(assert (!
  (forall ((c Constraint) (cs CList))
    (=> (elem c cs) (entails cs c)))
  :named C-Ident))
(assert (!
  (forall ((cs CList) (p Path) (c String))
    (=> (and (class c)
             (entails cs (instantiated-by p c)))
        (entails cs (instance-of p c))))
  :named C-Class))
(assert (!
  (forall ((cs1 CList) (cs2 CList)
           (b Constraint) (c Constraint))
    (=> (and (entails cs1 c)
             (entails (construct c cs2) b))
        (entails (conc cs1 cs2) b)))
  :named C-Cut))
\end{lstlisting}
\caption{SMTLib $DC_C$ Rules}
\label{fig:smtlib-basic-rules}
\end{figure}
A SMTLib representation for the $DC_C$ rules C-Refl,
C-Ident, C-Class and \mbox{C-Cut}, that do not
require enumeration, is given in \Cref{fig:smtlib-basic-rules}.
The structural rules of the sequent calculus C-Weak and C-Perm
are defined in \Cref{fig:smtlib-structural-rules}.\\
The keyword \smtlib{assert} is used to add an assertion
to the solver and the keyword \smtlib{!} can be used to
annotate a formula.
Annotation is done via adding a key-value pair to a formula,
where the key specifies the name of the annotated property.\\
We \textit{named} the rules according to their names in the calculus.
This enables the solver to produce an unsatisfiable core
for an unsatisfiable entailment,
by returning the names of the violated rules.
%
\begin{figure}[h]
\begin{lstlisting}[language=smtlib]
(assert (!
  (forall ((cs CList) (a Constraint) (b Constraint))
    (=> (entails cs b)
        (entails (construct a cs) b)))
  :named C-Weak))
(assert (!
  (forall ((cs1 CList) (cs2 CList) (c Constraint))
    (=> (and (forall ((a Constraint))
               (and (=> (elem a cs1) (elem a cs2))
                    (=> (not (elem a cs1)) (not (elem a cs2)))
             ))
             (entails cs1 c))
        (entails cs2 c)))
  :named C-Perm))
\end{lstlisting}
\caption{SMTLib Structural Rules}
\label{fig:smtlib-structural-rules}
\end{figure}\\
%
\begin{figure}[t]
\begin{lstlisting}[language=smtlib]
(define-fun-rec big-or-Entails ((ccs CsList) (cs CList)) Bool
  (ite (is-cons ccs)
    (or (Entails cs (hd ccs))
        (big-or-Entails (tl ccs) cs))
     false))
(assert (!
  (forall ((cs CList) (c Constraint))
    (let ((ccs (lookup-program-entailment c)))
      (=> (and (not (= ccs nan))
               (big-or-Entails ccs cs))
          (entails cs c))))
  :named C-Prog))
\end{lstlisting}
\caption{SMTLib C-Prog and Helper Function}
\label{fig:smtlib-cprog}
\end{figure}
%
\Cref{fig:smtlib-cprog} shows a SMTLib representation
of the refined rule C-Prog defined in \Cref{fig:axioms-cprog}.\\
The function \smtlib{big-or-Entails} models
$\bigvee_{\ovl b \in ccs}{\entails{cs}{\ovl b}}$
as used in the refined model of rule C-Prog.
The function \smtlib{lookup-program-entailment} is a lookup
function of the form seen in \Cref{ex:lookup-fun}.

\subsubsection{SMTLib Format in Scala}
%
\lstset{ language=scala,basicstyle=\small }
%
We modeled the SMTLib format in Scala as an AST.
Each node of the AST knows how to format itself
and formatting will be propagated to each sub-node.\\
\Cref{fig:scala-format} shows 
\lstinline{trait SMTLibFormatter}, as well as
\lstinline{object SMTLibFormatter}.
The trait provides the function \lstinline{format}
and each node inherits from this trait.
The singleton \lstinline{object SMTLibFormatter}
provides a function for formatting a SMTLib formattable
sequence using a specifiable separator.
%
\begin{figure}[h]
\begin{subfigure}[c]{1\textwidth}
\begin{lstlisting}
trait SMTLibFormatter {
  def format(): String
}
\end{lstlisting}
\end{subfigure}
\begin{subfigure}[c]{1\textwidth}
\begin{lstlisting}
object SMTLibFormatter {
  def format(seq: Seq[SMTLibFormatter]
           , separator: String = " "): String =
    seq.foldRight(""){
    (x, xs) => s"${x.format()}$separator$xs"}.dropRight(1)
}
\end{lstlisting}
\end{subfigure}
\caption{SMTLib Formatting in Scala}
\label{fig:scala-format}
\end{figure}\\
%
\Cref{ex:scala-format} shows the implementation
of the universal quantifier.\\
The \lstinline{trait Term} models the category \textit{term}
of the SMTLib format.
The universal quantifier is a member of this category
and therfore \lstinline{case class Forall}\ inherits from \lstinline{trait Term}.\\
The format of an universal quantifier is defined
in \lstinline{case class Forall} and starts
with the keyword \smtlib{forall}.
The keyword is followed by the format of the quantified variables
enclosed in parens and by the format of the body.
Finally the formatted components are enclosed in parens
to obtain the format of the quantifier.
%
\begin{example}[SMTLib Implementation: Universal quantification]
\label{ex:scala-format}
\begin{lstlisting}
trait Term extends SMTLibFormatter

case class Forall(vars: Seq[SortedVar], body: Term) extends Term {
  override def format(): String =
    s"(forall (${SMTLibFormatter.format(vars)}) ${body.format()})"
}
\end{lstlisting}
\end{example}

\subsubsection{Preprocessing Variable Names and Paths}
The previously shown SMTLib representation is
missing the refined components of the model,
which enumerate over variable names and paths.

\paragraph{Lookup Function generation}
is the process described in \Cref{sec:cprog},
with the goal to generate a function modeling
the existence check of program entailments
combined with the search for a substitution
to match the right-hand side from the entailment
to be shown to an entailment declaration of the program.

\begin{lstlisting}[caption={Lookup Function Generation},label=lst:lookup,captionpos=b,frame={lines}]
def makeProgramEntailmentLookupFunction(
        p: Program, paths: List[Path]): SMTLibCommand = {
  val x = SimpleSymbol("c")
  val body = makeProgramEntailmentLookupFunctionBody(
        paths.flatMap(instantiateProgramEntailments(p, _)), x)

  DefineFun(FunctionDef(
    SimpleSymbol("lookup-program-entailment"),
    Seq(SortedVar(x, SimpleSymbol("Constraint"))),
    SimpleSymbol("CsList"),
    body
  ))
}

private def instantiateProgramEntailments(p: Program, path: Path
  , entailments: Map[Constraint, List[List[Constraint]]] = Map())
              : Map[Constraint, List[List[Constraint]]] = p match {
  case Nil => entailments
  case ConstraintEntailment(x, as, a) :: rst =>
    val cs: List[Constraint] = substitute(x, path, as)
    val c: Constraint = substitute(x, path, a)
    entailments.get(c) match {
      case None => instantiateProgramEntailments(
                     rst, path, entailments + (c -> List(cs)))
      case Some(ccs) => instantiateProgramEntailments(
                     rst, path, entailments + (c -> (cs :: ccs)))
    }
  case _ :: rst => instantiateProgramEntailments(
                     rst, path, entailments)
}

private def makeProgramEntailmentLookupFunctionBody(
   entailments: List[(Constraint, List[List[Constraint]])], x: Term)
                          : Term = entailments match {
  case Nil => SimpleSymbol("nan")
  case (c, ccs) :: rst =>
    Ite(
      Eq(x, convertConstraint(c)),
      Axioms.makeCsList(
        ccs.map(cs => Axioms.makeList(cs.map(convertConstraint)))
      ),
      makeProgramEntailmentLookupFunctionBody(rst, x)
    )
}
\end{lstlisting}
%
\Cref{lst:lookup} shows the Scala implementation
of the lookup function generation.

- function makeProgamEntailmentLookupFunction\\
  - arguments: program, paths to instantiate\\
  - returns: SMTLib AST function definition\\
- signature of returned function (maps from to): constraint  \Constrs


\paragraph{Subst Rule}

- these are lookup and subst rules gen \\
- lookup function generation\\
- subst rules generation
\subsubsection{Calling the Solver}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: 
