\chapter{Introduction}
\section{Motivation}
Dynamic dispatch is the process to determine
the implementation of a polymorphic method
to call at runtime.
In contrast to static dispatch,
which determines this during compile time.
%
Safety describes the ability of a language
to prevent errors.
%
In object oriented programming
related classes can be grouped together,
but inheritance between those groups can not be expressed.

Dependent Classes~\cite{dc} combine dynamic dispatch à la Smalltalk~\cite{smalltalk}
with safety à la Scala~\cite{scala},
as well as supporting inheritance between groups of related classes.
The support for abstract methods is yet to be fully explored.
The $DC_C$ calculus by Vaidas Gasiūnas~\cite{vaidas:thesis}
captures the semantics of Dependent Classes
and extends it with the support for abstract classes and methods.
Subtyping in the $DC_C$ calculus is expressed as constraint entailment.

The goal of this thesis is to implement the $DC_C$ calculus
and to explore the usage of SMT to solve the constraint system of the calculus.

%- dynamic dispatch
%  - selecting which implemenetation of a polymorphic method to call at runtime
%  - in contrast to static dispatch which does this at compile time
%- (type) safety
%  - describes the ability to discourage/prevent errors (during compile time? → not really, dynamic typing)
%- dependent calsses
%  - combine dynamic dispatch and safety
%  - not yet/still a problem: abstract methods
%  - DCC calculus by vaidas: dependent classes with abstract methods
%  - subtyping can be described/expressed as constraint entailment
%  - not much explored in an object oriented setting
%  - use SMT solver to explore it

\section{Contributions}
The main contributions of the thesis are:
\begin{itemize}
  \item An implementation of the $DC_C$ calculus
        using SMT solving to resolve the constraint system.
  \item A first-order model of the $DC_C$ constraint system,
        which translates the rules of a sequent calculus
        to universal quantified formulae.
  \item Optimizations to the rules of the first-order model,
        such that a SMT solver can make better use of them.
  \item An implementation of the $DC_C$ relation for
        type assignments to expressions.
  \item A way to use type information of an expression
        in the interpretation of that expression
        to reduce the time to solve the constraint system.
\end{itemize}

\section{Structure}
\Cref{chp:pre} presents preliminaries.
We introduce Satisfiability Modulo Theories,
Dependent Classes and the $DC_C$ calculus.\\
\\
\Cref{chp:impl} gives an implementation of the $DC_C$ calculus.
We implement
the constraint system in \Cref{sec:constraintsystem},
the operational semantics in \Cref{sec:interp} and
the type relation in \Cref{sec:types}.\\
\\
\Cref{chp:learning} presents an approach
to use information gained from compile time (type checker)
during runtime (interpreter).\\
\\
Related work is discussed in \Cref{chp:related}
and we conclude the thesis in \Cref{chp:discuss}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: 
