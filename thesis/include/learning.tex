\chapter{Improving Interpreter with Type Information}
In the $DC_C$ calculus we need to solve a constraint system
when interpreting an expression, as well when type checking a program.
The need to solve a constraint system during runtime produces unwanted overhead,
as solving the constraint system takes some time.

For example, we interpreted a method call in \Cref{ex:eval-call}.
During evaluation, we needed to find the most specific method
that was applicable to the provided parameter.
For this we needed to solve a constraint entailment
for each method implementation.
Another example is the type checking of the natural numbers program
as seen in \Cref{ex:wf-naturalnumbers}.
There, we again needed to call the SMT solver.

In both examples, we needed to solve constraint entailments during execution.
There are two cases to consider: The solver
\begin{enumerate}
  \item does find a derivation.
  \item does not find a derivation.
\end{enumerate}
For (1):
If solver finds a derivation,
the constraint entailment holds.
The amount of time it takes the solver to find this derivation
is between $0$ and \mIt{limit},
where \mIt{limit} is the maximum amount of time before the solver returns \smtlib{unknown}.\\
\\
For (2):
If the solver finds a contradiction of the constraint entailment to the rules,
the execution time of the solver is between $0$ and \mIt{limit}.
If the SMT solver does not a contradiction for the constraint entailment,
the time it takes for the solver to return is \mIt{limit},
as in those cases the solver needs to evaluate all possible rule instantiations
to find either a derivation or a contradiction.
In both examples, we try to solve constraint entailments that have no derivation.\\
\\
While the provided implementation of the $DC_C$ calculus
can surely be further optimized without
touching the model of the constraint system,
this is an inherent problem of the $DC_C$ calculus.\\
\\
FOOOOOOOOOOOOOOO


\quad\\\\\\\\\\
%- in the $DC_C$ calculus it is needed to solve a constraint system during runtime
%- this produces overhead not wanted during runtime 
%  - as solving can take a while
%    - up to multiple minutes etc
%    - eg typechecking the natural numbers program already takes ~40 sec in the provided implementation
- would be cool if the need for solving a constraint system could be removed (benificial?)
- removal is too optimistic (not doable)
- alternative goal is to minimize the time needed to solve the constraint system
- time needed for solving depends on the size of the search space
- the search space scales with
  - the provided axioms
    - amount of variables in a quantifier
    - amount of rules
  - the context of an entailment: context |- c
    - we can add restrictions by adding constraints into the context
- the quantified variables are used to match the entailment as an input
- we need the amount of rules, to be able to show entailments
- grounding variables introduces additional rules, as seen in the C-Subst generation
- removal of rules, makes the model uncomplete. as seen in the pruning process
- adding additional constraints to the context doesnt alter any rules
- need to make sure that the added constraints do not contradict the context
  - a contradiction in the context means that we could show anything and invalidating soundness (perhaps?)
- how to find constraints that do not contradict?
- types are constraints with a bound variable
- if t := (x, a) is type of e
  - then all constraints a hold for each possible instance of e
- idea: add type constraints into the context when interpreting e
- need to find substitution, since t has bound variable
  - substitution must unify x with the variable e reduces to in a

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: 
