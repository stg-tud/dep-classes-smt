\section{Interpreter}
In this section we implement
the operational semantics of the $DC_C$ calculus
presented in \Cref{fig:dcc-opsemantics}.
For this we define an interpreter,
which will evaluate expressions relative to a heap.
The operational semantics is a small-step semantics over
the structure of expressions.
%
\begin{lstlisting}[caption={Interpreter},label=lst:interp,captionpos=b,frame={lines}]
def interp(heap: Heap, expr: Expression)
          : (Heap, Expression) = expr match {
  // R-Field
  case FieldAccess(X@Id(_), F@Id(_)) =>
    HC(heap).filter{
        case PathEquivalence(FieldPath(X, F), Id(_)) => true
        case PathEquivalence(Id(_), FieldPath(X, F)) => true
        case _ => false
        } match {
      case PathEquivalence(FieldPath(X, F), y@Id(_)) :: _ =>
        (heap, y)
      case PathEquivalence(y@Id(_), FieldPath(X, F)) :: _ =>
        (heap, y)
      case _ => (heap, expr) // x does not has field f
    }
  // R-Call
  case MethodCall(m, x@Id(_)) =>
    // Applicable methods
    val S: List[(List[Constraint], Expression)] =
        mImplSubst(m, x).filter{
          case (as, _) => entails(HC(heap), as)}

    var (a, e) = S.head // Most specific method
    S.foreach{
      case (a1, e1) if e != e1 =>
        if (entails(a1, a) && !entails(a, a1)) {
          a = a1
          e = e1
        }
    }
    (heap, e)
  // R-New
  case ObjectConstruction(cls, args)
    if args.forall{ // if args are values (Id)
      case (_, Id(_)) => true
      case _ => false
    } =>
    val x: Id  = freshvar()
    val args1: List[(Id, Id)] = args.map{
      case (f, Id(z)) => (f, Id(z))} // case (f, _) => (f, Id('notReduced)) guard makes sure everything is an Id TODO: remove this comment after describing the case because its too friggin long for the thesis
    val o: Obj = (cls, args1)
    // cls in Program: alpha renaming of y to x in b
    val (y: Id, b: List[Constraint]) =
      classInProgram(cls, P).getOrElse(return (heap, expr))
    val b1 = substitute(y, x, b)
    // heap constraints entail cls constraints
    if (entails(HC(heap) ++ OC(x, o), b1))
      (heap + (x -> o), x)
    else
      (heap, expr) // stuck
      
  // RC-Field
  case FieldAccess(e, f) =>
    val (h1, e1) = interp(heap, e)

    if(h1 == heap && e1 == e) {
      (heap, expr) // stuck
    } else {
      interp(h1, FieldAccess(e1, f)) // recursive call for big-step TODO: remove this comment like the one above
    }
    
  // RC-Call
  case MethodCall(m, e) =>
    val (h1, e1) = interp(heap, e)

    if(h1 == heap && e1 == e) {
      (heap, expr) // stuck
    } else {
      interp(h1, MethodCall(m, e1))
    }
    
  // RC-New
  case ObjectConstruction(cls, args) =>
    val (h1, args1) = objArgsInterp(heap, args)

    if(h1 == heap && args1 == args) {
      (heap, expr) // stuck
    } else {
      interp(h1, ObjectConstruction(cls, args1))
    }
    
    case Id(_) => (heap, expr) // variables are values
}
\end{lstlisting}
%
\newpage
We define function \scala{interp} in \Cref{lst:interp}.
The function takes a heap and an expression
as arguments and returns a heap and an expression.
The implementation follows the structure of the operational
semantics.
This is done via pattern matching on the argument expression
and allows to recreate each rule from \Cref{fig:dcc-opsemantics}
as a separate case in the implementation.

% TODO: describe cases
- no small-step implementation, do not return intermediate results
- field access
  - requires subexpr to be variable
  - stable identifiers X, F
    - used in filter
    - search heap constraints for path eq X.F = y
    - return y
- method call
  - requires arg to be variable
  - generate list of applicable methods
    by calling mImplSubst
  - mImplSubst does incorporate implicit unification of formal argument to x
  - determine most specific method
    - set first applicable as most specific
    - for each applipacle method
      - try if more suitable than current
  - return most specific method body
- object creation
  - requires arguments to be evaluated to vars
  - fresh var for the object to be created
  - args1: typechange of args since object type requires List[Id]
  - create new object, set fields from args
  - search if constructor for class exists in program
    + retrieve constructor/class constraints
  - if class not in program â†’ stuck
  - substitute bound var of class constraints
    with var of newly created object
  - check if the heap entails the class constraints
  - if so, put the new object on the heap
    otherwise stuck
- recursive cases
  - stuck terms to avoid endless recursion
  - for new obj: interp arguments in one go  
- added special case Id(_)
  - variables are values in DCC
  - add case to avoid undefined function input

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: 
