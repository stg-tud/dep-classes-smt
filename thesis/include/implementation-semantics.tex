\section{Interpreter}
In this section we implement
the operational semantics of the $DC_C$ calculus
presented in \Cref{fig:dcc-opsemantics}.
For this we define an interpreter,
which will evaluate expressions relative to a heap.
The operational semantics is a small-step semantics over
the structure of expressions.
%
\begin{lstlisting}[caption={Interpreter},label=lst:interp,captionpos=b,frame={lines}]
def interp(heap: Heap, expr: Expression)
          : (Heap, Expression) = expr match {
  case FieldAccess(X@Id(_), F@Id(_)) =>   // R-Field
    HC(heap).filter{
        case PathEquivalence(FieldPath(X, F), Id(_)) => true
        case PathEquivalence(Id(_), FieldPath(X, F)) => true
        case _ => false
        } match {
      case PathEquivalence(FieldPath(X, F), y@Id(_)) :: _ =>
        (heap, y)
      case PathEquivalence(y@Id(_), FieldPath(X, F)) :: _ =>
        (heap, y)
      case _ => (heap, expr) // f no field of x
    }
  // R-Call
  case MethodCall(m, x@Id(_)) =>
    // Applicable methods
    val S: List[(List[Constraint], Expression)] =
        mImplSubst(m, x).filter{
          case (as, _) => entails(HC(heap), as)}
    if (S.isEmpty) // m not in program
      (heap, expr)

    var (a, e) = S.head // Most specific method
    S.foreach{
      case (a1, e1) if e != e1 =>
        if (entails(a1, a) && !entails(a, a1)) {
          a = a1; e = e1
        }
    }
    interp(heap, e)
  // R-New
  case ObjectConstruction(cls, args)
    if args.forall{ // if args are values (Id)
      case (_, Id(_)) => true
      case _ => false
    } =>
    val x: Id  = freshvar()
    val o: Obj = (cls, args.asInstanceOf[List[(Id, Id)]])
    // cls in Program: alpha renaming of y to x in b
    val (y: Id, b: List[Constraint]) =
      classInProgram(cls, P).getOrElse(return (heap, expr))
    val b1 = substitute(y, x, b)
    // heap constraints entail cls constraints
    if (entails(HC(heap) ++ OC(x, o), b1))
      (heap + (x -> o), x)
    else
      (heap, expr) // stuck
      
  // RC-Field
  case FieldAccess(e, f) =>
    val (h1, e1) = interp(heap, e)

    if(h1 == heap && e1 == e) {
      (heap, expr) // stuck
    } else {
      interp(h1, FieldAccess(e1, f)) // recursive call for big-step TODO: remove this comment like the one above
    }
    
  // RC-Call
  case MethodCall(m, e) =>
    val (h1, e1) = interp(heap, e)

    if(h1 == heap && e1 == e) {
      (heap, expr) // stuck
    } else {
      interp(h1, MethodCall(m, e1))
    }
    
  // RC-New
  case ObjectConstruction(cls, args) =>
    val (h1, args1) = objArgsInterp(heap, args)

    if(h1 == heap && args1 == args) {
      (heap, expr) // stuck
    } else {
      interp(h1, ObjectConstruction(cls, args1))
    }
    
    case Id(_) => (heap, expr) // variables are values
}
\end{lstlisting}
%
\newpage
We define function \scala{interp} in \Cref{lst:interp}.
The function takes a heap $heap$ and an expression $expr$
as arguments and returns a heap and an expression.
We do not return intermediate steps in the function,
but fully evaluate the argument expression to a value.
The implementation follows the structure of the operational
semantics.
This is done via pattern matching on the argument expression
and allows to recreate each rule from \Cref{fig:dcc-opsemantics}
as a separate case in the implementation.\\
\\
The first case implements rule R-Field,
it is marked in the Scala code with the comment R-Field.
We match for field access $e.f$, where the subexpression $e$
is evaluated to a variable.
Variables are the values of the $DC_C$ calculus.
We then build the heap constraints $HC(heap)$
and filter them to check if they contain \pathEq{x.f}{y}
or \pathEq{y}{x.f} for some variable $y$.
If such a path equivalence exists, we
reduce $x.f$ to $y$ and return
the pair $(heap, y)$.
Otherwise we can not reduce $x.f$,
because field $f$ is not a member of the object
corresponding to $x$ in the heap.
We return the arguments $(heap, expr)$
as there are no subsequent transitions.\\
\\
For rule R-Call, we match for method calls $m(x)$,
where $x$ is a value.
First, we generate the list of applicable methods $S$.
For this we call $\mIt{mImplSubst}(m, x)$
to search for all implementations of method $m$
and filter its result to check if the
argument constraints are entailed by the heap.
Function \mIt{mImplSubst} implements \mIt{mImpl}
defined in \Cref{fig:dcc-syntax}.
In \mIt{mImplSubst} we explicitly incorporated the unification
of the formal argument of method implementations with $x$,
since the unification is implicit in the operational semantics.
If $S$ is empty, there is no implementation for $m$ in the program
and we can not reduce $m(x)$.
Afterwards, we determine the most specific method implementation.
With $(a, e) := S.head$, we set the first applicable method
as the currently most specific method.
We then try for each applicable method $(a_1, e_1)$ where $e \not= e_1$,
if \entails{a_1}{a} and not \entails{a}{a_1}.
If so we update the most specific method $(a, e) := (a_1, e_1)$.
After all applicable methods have been checked, we reduce
$m(x)$ to the body $e$ of the most specific implementation of $m$.
Since we do not want to produce intermediate results and $e$
is not guaranteed to be a value we recursively call \scala{interp(heap, e)}.
%
\begin{figure}[h]
\begin{lstlisting}
private def mImplSubst(
    m: Id, x: Id): List[(List[Constraint], Expression)] =
  P.foldRight(Nil: List[(List[Constraint], Expression)]){
    case (MethodImplementation(`m`, y, a, _, e), rst) =>
      (substitute(y, x, a),
       alphaRename(y, x, e)) :: rst
    case (_, rst) => rst
  }
\end{lstlisting}
\caption{Function \scala{mImplSubst}}
\label{fig:scala-mimpl}
\end{figure}\\
%
The implementation of $\mIt{mImplSubst}(m, x)$ is given in \Cref{fig:scala-mimpl}.
In the implementation we fold over declarations of program $P$.
In the case of a method implementation \mImpl{m}{y}{a}{\_}{e},
we substitute the formal argument $y$ with $x$ in constraints $a$
and apply $\alpha$-renaming of $y$ to $x$ in the method body $e$.\\
%
For rule R-New we match for object creations \objConstr{cls}{args},
where $\mIt{args}$ has the type \scala{List[(Id, Expression)]}
and the argument expressions are reduced to values.\\
We generate a fresh variable $x$ for the object to be constructed
and set object $o := (\mIt{cls}, \mIt{args})$, % $o := (\mIt{cls}, \mIt{args.asInstanceOf}[\mIt{List}[(\mIt{Id}, \mIt{Id})]])$,
where \mIt{args} are cast to \scala{List[(Id, Id)]}.
This is a safe typecast, since we ensured
that the argument expressions are values.\\
We search for a constructor \constr{cls}{y}{b} in the program.
If there is no constructor for class \mIt{cls},
we can not reduce \objConstr{cls}{args}.
If we found a constructor,
we substitute the formal argument of the constructor $y$
with the variable of the object to be created $x$
in the constructor constraints $b$.
We obtain $b_1 := \subst{b}{y}{x}$.
We check if the heap constraints combined
with the constraints of $o$ entail $b_1$.
If so, we reduce \objConstr{cls}{args} to $x$
and extend the heap with the mapping from $x$ to $o$.
Otherwise, we can not reduce \objConstr{cls}{args}.


\quad\\\\\\
% TODO: describe cases
- recursive cases / congruence rules
  - stuck terms to avoid endless recursion
  - for new obj: interp arguments in one go  
- added special case Id(_)
  - variables are values in DCC
  - add case to avoid undefined function input

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: 
