\section{Interpreter}
In this section we will implement
the operational semantics of the $DC_C$ calculus
presented in \Cref{fig:dcc-opsemantics}.
For this we will define an interpreter,
which will evaluate expressions relative to a heap.

\begin{lstlisting}[caption={Interpreter},label=lst:interp,captionpos=b,frame={lines}]
def interp(heap: Heap, expr: Expression)
          : (Heap, Expression) = expr match {
  // R-Field
  case FieldAccess(X@Id(_), F@Id(_)) =>
    HC(heap).filter{
        case PathEquivalence(FieldPath(X, F), Id(_)) => true
        case PathEquivalence(Id(_), FieldPath(X, F)) => true
        case _ => false
        } match {
      case PathEquivalence(FieldPath(X, F), y@Id(_)) :: _ =>
        (heap, y)
      case PathEquivalence(y@Id(_), FieldPath(X, F)) :: _ =>
        (heap, y)
      case _ => (heap, expr) // x does not has field f
    }
  // R-Call
  case MethodCall(m, x@Id(_)) =>
    // Applicable methods
    val S: List[(List[Constraint], Expression)] =
        mImplSubst(m, x).filter{
          case (as, _) => entails(HC(heap), as)}

    var (a, e) = S.head // Most specific method
    S.foreach{
      case (a1, e1) if e != e1 =>
        if (entails(a1, a) && !entails(a, a1)) {
          a = a1
          e = e1
        }
    }
    (heap, e)
  // R-New
  case ObjectConstruction(cls, args)
    if args.foldRight(true){ // if args are values (Id)
      case ((_, Id(_)), rst) => rst
      case _ => false
    } =>
    val x: Id  = freshvar()
    val args1: List[(Id, Id)] = args.map{
      case (f, Id(z)) => (f, Id(z))} // case (f, _) => (f, Id('notReduced)) guard makes sure everything is an Id TODO: remove this comment after describing the case because its too friggin long for the thesis
    val o: Obj = (cls, args1)
    // cls in Program: alpha renaming of y to x in b
    val (y: Id, b: List[Constraint]) =
      classInProgram(cls, P).getOrElse(return (heap, expr))
    val b1 = alphaConversion(y, x, b)
    // heap constraints entail cls constraints
    if (entails(HC(heap) ++ OC(x, o), b1))
      (heap + (x -> o), x)
    else
      (heap, expr) // stuck
      
  // RC-Field
  case FieldAccess(e, f) =>
    val (h1, e1) = interp(heap, e)

    if(h1 == heap && e1 == e) {
      (heap, expr) // stuck
    } else {
      interp(h1, FieldAccess(e1, f)) // recursive call for big-step TODO: remove this comment like the one above
    }
    
  // RC-Call
  case MethodCall(m, e) =>
    val (h1, e1) = interp(heap, e)

    if(h1 == heap && e1 == e) {
      (heap, expr) // stuck
    } else {
      interp(h1, MethodCall(m, e1))
    }
    
  // RC-New
  case ObjectConstruction(cls, args) =>
    val (h1, args1) = objArgsInterp(heap, args)

    if(h1 == heap && args1 == args) {
      (heap, expr) // stuck
    } else {
      interp(h1, ObjectConstruction(cls, args1))
    }
}
\end{lstlisting}
%
\newpage
The function \lstinline{interp} \scala{interp} defined 

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: 
