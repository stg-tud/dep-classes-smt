\subsection{$DC_C$ Calculus}
The $vc^n$ calculus does not support abstract classes and methods.
The $DC_C$ calculus\cite{vaidas:thesis} extends $vc^n$ with support for abstract classes and methods
and symmetric method dispatch.
$DC_C$ encodes dependent classes with a constraint system,
which is used in both the static and dynamic semantics.
The main relation of the $DC_C$ calculus is constraint entailment,
replacing $vc^n$'s relations for type equivalence, subtyping, static and dynamic dispatch.

The runtime structure is heap based,
with explicit object identities
and relationships between objects based on these identities.
Expressions evaluate to an identifier pointing to an object in the heap.
Heaps preserve object identity and enable shared references to objects.
The heap provides a direct interpretation for equivalent paths,
two paths are equivalent if they point to the same object at runtime.
Heaps can be easily translated to a set of constraints describing its objects and their relations,
which enables the usage of the constraint system for dynamic dispatch and expression typing.
%- DCc extends $vc^n$ with abstract methods and classes and symmetric method dispatch
%- gave up unification of methods and classes
%- runtime structure: heap
%- heap structure preserves object identity, enables shared references
%- heap provides direct interpretation for equivalent paths
%    - paths are equiv if they point to the same object at runtime
%- heaps can be easily translated to a set of constraints describing its objects and their relations
%    - enables using constraint system for dynamic dispatch and expression typing
\subsubsection{Syntax}
The syntax of $DC_C$ is given in figure 2.2.
Types are lists of constraints to be satisfied by their instances.
Types have the form $[x. \overline(a)]$, where $x$ is a bound variable
and $\overline(a)$ is a list of constraints on $x$.
An object belongs to a type if it fulfills its constraints.

Constraints of the form $p \equiv q$ express that two paths $p$ and $q$ are equivalent
and paths are considered to be equivalent if they refer to the same object at runtime.
$p :: C$ specifies that path $p$ refers to an instance of class $C$.
The stronger form $p.\textbf{cls} \equiv C$ denotes that
path $p$ refers to an object instantiated by a constructor of class $C$,
excluding indirect instances of $C$ inferred through inheritance rules.

A Program $P$ consists of a list of declarations $D$.
Possible declarations are constructor declarations,
abstract method declarations, method implementations and constraint entailment rules.

A Path expression can be a variable $x$ or navigation over fields starting from a variable e.g. $x.f$.

Expressions can be variables, field access, object construction and method invocation.
Field assignments are not supported since the calculus is functional.

% begin syntax figure
\begin{figure}
\setlength{\grammarindent}{5em} % increase separation between LHS/RHS
% TODO: use <> on construction at rhs?
\begin{grammar}
<Program>  ::= $\overline{Decl}$

<Decl> ::= \constr{C}{x}{\overline{Constr}} % C(x. $\overline{Constr}$)
       | \progEnt{x}{\overline{Constr}}{Constr}
       \alt \mDecl{m}{x}{\overline{Constr}}{Type} % m(x. $\overline{Constr}$): Type
       | \mImpl{m}{x}{\overline{Constr}}{Type}{Expr} % m(x. $\overline{Constr}$): Type := Expr

<Type> ::= [x. $\overline{Constr}$]

<Constr> ::= \pathEq{Path}{Path} % Path $\equiv$ Path
           | \instOf{Path}{C} % Path :: C
           | \instBy{Path}{C} % Path.\textbf{cls} $\equiv$ C

<Path> ::= x
       | Path.f

<Expr> ::= x
       | Expr.f
       | \newInst{C}{\overline{f}}{\overline{Expr}} % \textbf{new} C($\overline{f}$ $\equiv$ $\overline{Expr}$)
       | m(Expr)
\end{grammar}

\begin{align*}
MType(m, x, y) &= \{ \langle\overline{a}, \overline{b}\rangle | (m(x. \overline{a}): [y. \overline{b}]...) \in P \} \\
MImpl(m, x) &= \{\langle\overline{a}, e\rangle | (m(x. \overline{a}): [y. \overline{b}] := e) \in P \}
\end{align*}

x, y $\in$ variable names\\
f $\in$ field names\\
C $\in$ class names\\
m $\in$ method names
\caption{Syntax}
\end{figure}
% end syntax figure

\subsubsection{Constraint System}
% begin constraint system figure
\begin{figure}
% C-Ident
\begin{prooftree}
\AxiomC{}
\RightLabel{(C-Ident)}
\UnaryInfC{\entails{a}{a}}
\end{prooftree}
% C-Refl
\begin{prooftree}
\AxiomC{}
\RightLabel{(C-Refl)}
\UnaryInfC{\entails{\epsilon}{\pathEq{p}{p}}}
\end{prooftree}
% C-Class
\begin{prooftree}
\AxiomC{\entails{\overline{a}}{\instantiatedBy{p}{C}}}
\RightLabel{(C-Class)}
\UnaryInfC{\entails{\overline{a}}{\instanceOf{p}{C}}}
\end{prooftree}
% C-Cut
\begin{prooftree}
\AxiomC{\entails{\overline{a}}{c}}
\AxiomC{\entails{\overline{a'}, c}{b}}
\RightLabel{(C-Cut)}
\BinaryInfC{\entails{\overline{a},\overline{a'}}{b}}
\end{prooftree}
% C-Subst
\begin{prooftree}
\AxiomC{\entails{\overline{a}}{a_{\sub{x}{p}}}}
\AxiomC{\entails{\overline{a}}{\pathEq{p'}{p}}}
\RightLabel{(C-Subst)}
\BinaryInfC{\entails{\overline{a}}{a_{\sub{x}{p'}}}}
\end{prooftree}
% C-Prog
\begin{prooftree}
\AxiomC{$(\progEnt{x}{\overline{a}}{a}) \in P$}
\AxiomC{\entails{\overline{b}}{\overline{a}_{\sub{x}{p}}}}
\RightLabel{(C-Prog)}
\BinaryInfC{\entails{\overline{b}}{a_{\sub{x}{p}}}}
\end{prooftree}
\caption{Constraint Entailment}
\end{figure}
% end constraint system figure

\subsubsection{Operational Semantics}
% begin Operational Semantics figure
\begin{figure}
% TODO: both alignments side-by-side
\begin{align*}
o &::= \stdobj \\ % \langle C; \overline{f} \equiv \overline{x} \rangle \\
h &::= \stdheap\ \ (x_i \text{ distinct})
\end{align*}
\begin{align*}
OC(x, o) &= (\instBy{x}{C}, \pathEq{x.\overline{f}}{\overline{x}}) &&\text{where } o = \stdobj \\ % \langle C; \overline{f}\equiv\overline{x} \rangle \\
HC(h) &= \bigcup_i OC(x_i, o_i) &&\text{where } h = \stdheap % \overline{x} \mapsto \overline{o}
\end{align*}
% vertical inference rule example
%\begin{prooftree}
%\AxiomC{$A\lor B$}
%\AxiomC{$[A]$}
%\noLine
%\UnaryInfC{$C$}
%\AxiomC{$[B]$}
%\noLine
%\UnaryInfC{$C$}
%\TrinaryInfC{$C$}
%\end{prooftree}
% R-New
\begin{prooftree}
\AxiomC{$x \not \in dom(h)$}
\noLine
\UnaryInfC{o = \stdobj}
\AxiomC{$\constr{C}{x}{\overline{b}} \in P$}
\noLine
\UnaryInfC{\entails{HC(h), OC(x, o)}{\overline{b}}}
\RightLabel{R-New}
\BinaryInfC{$\eval{h}{\newInst{C}{\overline{f}}{\overline{x}}}{h, x \mapsto o}{x}$}
\end{prooftree}
% R-Field
\begin{prooftree}
\AxiomC{$(\pathEq{x.f}{y}) \in HC(h)$}
\RightLabel{R-Field}
\UnaryInfC{\eval{h}{x.f}{h}{y}}
\end{prooftree}
% R-Call
\begin{prooftree}
\AxiomC{$S = \{ \pair{\overline{a}}{e}\ |\ \pair{\overline{a}}{e} \in MImpl(m, x) \land \entails{HC(h)}{\overline{a}} \}$}
\AxiomC{$\pair{\overline{a}}{e} \in S$}
\noLine
\BinaryInfC{$\forall \pair{\overline{a'}}{e'} \in S.\ (e' \neq e) \longrightarrow (\entails{\overline{a'}}{\overline{a}}) \land \neg(\entails{\overline{a}}{\overline{a'}})$}
\RightLabel{R-Call}
\UnaryInfC{\eval{h}{m(x)}{h}{e}}
\end{prooftree}
% RC-Field
\begin{prooftree}
\AxiomC{\eval{h}{e}{h'}{e'}}
\RightLabel{RC-Field}
\UnaryInfC{\eval{h}{e.f}{h'}{e'.f}}
\end{prooftree}
% RC-Call
\begin{prooftree}
\AxiomC{\eval{h}{e}{h'}{e'}}
\RightLabel{RC-Call}
\UnaryInfC{\eval{h}{m(e)}{j'}{m(e')}}
\end{prooftree}
% RC-New
\begin{prooftree}
\AxiomC{\eval{h}{e}{h'}{e'}}
\RightLabel{RC-New}
\UnaryInfC{ % TODO: too long for box
  \eval
    {h}
    {\newInst{C}
      {\overline{f} \equiv \overline{x}, f}
      {e, \overline{f'} \equiv \overline{e'}}}
    {h'}
    {\newInst{C}
      {\overline{f} \equiv \overline{x}, f}
      {e', \overline{f'} \equiv \overline{e'}}}}
\end{prooftree}

\caption{Operational semantics}
\end{figure}
% end Operational Semantics figure

\subsubsection{Type Checking}
% begin Type assignment figure
\begin{figure}
TODO
\caption{Type assignment}
\end{figure}
% end Type assignment figure
% begin Type Checking figure
\begin{figure}
TODO
\caption{Type checking}
\end{figure}
% end Type Checking figure

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: 
